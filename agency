#!/usr/bin/env node
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 63:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const commander_1 = __nccwpck_require__(855);
const fs_1 = __nccwpck_require__(896);
const agency_lang_1 = __nccwpck_require__(892);
const child_process_1 = __nccwpck_require__(317);
const program = new commander_1.Command();
program.name("agency").description("The Agency Language CLI").version("0.0.1");
program
    .command("run")
    .description("Run a .agency file")
    .argument("<filename>", "The .agency file to run")
    /*.option("--first", "display just the first substring")
     */
    /*   .option("-r, --region <string>", "AWS region (eg us-west-2)")
     */ .action((filename) => __awaiter(void 0, void 0, void 0, function* () {
    const contents = (0, fs_1.readFileSync)(filename, "utf-8");
    const program = (0, agency_lang_1.parseAgency)(contents);
    if (program.success === false) {
        console.error("Failed to parse .agency file:");
        console.error(program.message);
        process.exit(1);
    }
    const newFilename = filename.replace(/\.agency$/, ".ts");
    const tsCode = (0, agency_lang_1.generateGraph)(program.result);
    (0, fs_1.writeFileSync)(newFilename, tsCode);
    console.log(`Wrote temporary file to ${newFilename}`);
    // now run the file with ts-node
    const child = (0, child_process_1.spawn)("node", [newFilename], {
        stdio: "inherit",
    });
    child.on("exit", (code) => {
        // delete the temporary file
        // fs.unlinkSync(newFilename);
        process.exit(code !== null && code !== void 0 ? code : 0);
    });
}));
program
    .command("compile")
    .description("Compile a .agency file")
    .argument("<filename>", "The .agency file to compile")
    .option("-o, --out-file <file>", "File to write to (defaults to <filename>.ts");
program.parse();
function printOrWrite(output) {
    const options = program.opts();
    if (options.outFile) {
        // write to file
        console.log(`writing to file ${options.outFile}`);
        (0, fs_1.writeFileSync)(options.outFile, output);
    }
    else {
        console.log(output);
    }
}


/***/ }),

/***/ 317:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 896:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 421:
/***/ ((module) => {

"use strict";
module.exports = require("node:child_process");

/***/ }),

/***/ 474:
/***/ ((module) => {

"use strict";
module.exports = require("node:events");

/***/ }),

/***/ 24:
/***/ ((module) => {

"use strict";
module.exports = require("node:fs");

/***/ }),

/***/ 760:
/***/ ((module) => {

"use strict";
module.exports = require("node:path");

/***/ }),

/***/ 708:
/***/ ((module) => {

"use strict";
module.exports = require("node:process");

/***/ }),

/***/ 855:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

const { Argument } = __nccwpck_require__(464);
const { Command } = __nccwpck_require__(806);
const { CommanderError, InvalidArgumentError } = __nccwpck_require__(453);
const { Help } = __nccwpck_require__(420);
const { Option } = __nccwpck_require__(246);

exports.program = new Command();

exports.createCommand = (name) => new Command(name);
exports.createOption = (flags, description) => new Option(flags, description);
exports.createArgument = (name, description) => new Argument(name, description);

/**
 * Expose classes
 */

exports.Command = Command;
exports.Option = Option;
exports.Argument = Argument;
exports.Help = Help;

exports.CommanderError = CommanderError;
exports.InvalidArgumentError = InvalidArgumentError;
exports.InvalidOptionArgumentError = InvalidArgumentError; // Deprecated


/***/ }),

/***/ 464:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

const { InvalidArgumentError } = __nccwpck_require__(453);

class Argument {
  /**
   * Initialize a new command argument with the given name and description.
   * The default is that the argument is required, and you can explicitly
   * indicate this with <> around the name. Put [] around the name for an optional argument.
   *
   * @param {string} name
   * @param {string} [description]
   */

  constructor(name, description) {
    this.description = description || '';
    this.variadic = false;
    this.parseArg = undefined;
    this.defaultValue = undefined;
    this.defaultValueDescription = undefined;
    this.argChoices = undefined;

    switch (name[0]) {
      case '<': // e.g. <required>
        this.required = true;
        this._name = name.slice(1, -1);
        break;
      case '[': // e.g. [optional]
        this.required = false;
        this._name = name.slice(1, -1);
        break;
      default:
        this.required = true;
        this._name = name;
        break;
    }

    if (this._name.endsWith('...')) {
      this.variadic = true;
      this._name = this._name.slice(0, -3);
    }
  }

  /**
   * Return argument name.
   *
   * @return {string}
   */

  name() {
    return this._name;
  }

  /**
   * @package
   */

  _collectValue(value, previous) {
    if (previous === this.defaultValue || !Array.isArray(previous)) {
      return [value];
    }

    previous.push(value);
    return previous;
  }

  /**
   * Set the default value, and optionally supply the description to be displayed in the help.
   *
   * @param {*} value
   * @param {string} [description]
   * @return {Argument}
   */

  default(value, description) {
    this.defaultValue = value;
    this.defaultValueDescription = description;
    return this;
  }

  /**
   * Set the custom handler for processing CLI command arguments into argument values.
   *
   * @param {Function} [fn]
   * @return {Argument}
   */

  argParser(fn) {
    this.parseArg = fn;
    return this;
  }

  /**
   * Only allow argument value to be one of choices.
   *
   * @param {string[]} values
   * @return {Argument}
   */

  choices(values) {
    this.argChoices = values.slice();
    this.parseArg = (arg, previous) => {
      if (!this.argChoices.includes(arg)) {
        throw new InvalidArgumentError(
          `Allowed choices are ${this.argChoices.join(', ')}.`,
        );
      }
      if (this.variadic) {
        return this._collectValue(arg, previous);
      }
      return arg;
    };
    return this;
  }

  /**
   * Make argument required.
   *
   * @returns {Argument}
   */
  argRequired() {
    this.required = true;
    return this;
  }

  /**
   * Make argument optional.
   *
   * @returns {Argument}
   */
  argOptional() {
    this.required = false;
    return this;
  }
}

/**
 * Takes an argument and returns its human readable equivalent for help usage.
 *
 * @param {Argument} arg
 * @return {string}
 * @private
 */

function humanReadableArgName(arg) {
  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');

  return arg.required ? '<' + nameOutput + '>' : '[' + nameOutput + ']';
}

exports.Argument = Argument;
exports.humanReadableArgName = humanReadableArgName;


/***/ }),

/***/ 806:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

const EventEmitter = (__nccwpck_require__(474).EventEmitter);
const childProcess = __nccwpck_require__(421);
const path = __nccwpck_require__(760);
const fs = __nccwpck_require__(24);
const process = __nccwpck_require__(708);

const { Argument, humanReadableArgName } = __nccwpck_require__(464);
const { CommanderError } = __nccwpck_require__(453);
const { Help, stripColor } = __nccwpck_require__(420);
const { Option, DualOptions } = __nccwpck_require__(246);
const { suggestSimilar } = __nccwpck_require__(504);

class Command extends EventEmitter {
  /**
   * Initialize a new `Command`.
   *
   * @param {string} [name]
   */

  constructor(name) {
    super();
    /** @type {Command[]} */
    this.commands = [];
    /** @type {Option[]} */
    this.options = [];
    this.parent = null;
    this._allowUnknownOption = false;
    this._allowExcessArguments = false;
    /** @type {Argument[]} */
    this.registeredArguments = [];
    this._args = this.registeredArguments; // deprecated old name
    /** @type {string[]} */
    this.args = []; // cli args with options removed
    this.rawArgs = [];
    this.processedArgs = []; // like .args but after custom processing and collecting variadic
    this._scriptPath = null;
    this._name = name || '';
    this._optionValues = {};
    this._optionValueSources = {}; // default, env, cli etc
    this._storeOptionsAsProperties = false;
    this._actionHandler = null;
    this._executableHandler = false;
    this._executableFile = null; // custom name for executable
    this._executableDir = null; // custom search directory for subcommands
    this._defaultCommandName = null;
    this._exitCallback = null;
    this._aliases = [];
    this._combineFlagAndOptionalValue = true;
    this._description = '';
    this._summary = '';
    this._argsDescription = undefined; // legacy
    this._enablePositionalOptions = false;
    this._passThroughOptions = false;
    this._lifeCycleHooks = {}; // a hash of arrays
    /** @type {(boolean | string)} */
    this._showHelpAfterError = false;
    this._showSuggestionAfterError = true;
    this._savedState = null; // used in save/restoreStateBeforeParse

    // see configureOutput() for docs
    this._outputConfiguration = {
      writeOut: (str) => process.stdout.write(str),
      writeErr: (str) => process.stderr.write(str),
      outputError: (str, write) => write(str),
      getOutHelpWidth: () =>
        process.stdout.isTTY ? process.stdout.columns : undefined,
      getErrHelpWidth: () =>
        process.stderr.isTTY ? process.stderr.columns : undefined,
      getOutHasColors: () =>
        useColor() ?? (process.stdout.isTTY && process.stdout.hasColors?.()),
      getErrHasColors: () =>
        useColor() ?? (process.stderr.isTTY && process.stderr.hasColors?.()),
      stripColor: (str) => stripColor(str),
    };

    this._hidden = false;
    /** @type {(Option | null | undefined)} */
    this._helpOption = undefined; // Lazy created on demand. May be null if help option is disabled.
    this._addImplicitHelpCommand = undefined; // undecided whether true or false yet, not inherited
    /** @type {Command} */
    this._helpCommand = undefined; // lazy initialised, inherited
    this._helpConfiguration = {};
    /** @type {string | undefined} */
    this._helpGroupHeading = undefined; // soft initialised when added to parent
    /** @type {string | undefined} */
    this._defaultCommandGroup = undefined;
    /** @type {string | undefined} */
    this._defaultOptionGroup = undefined;
  }

  /**
   * Copy settings that are useful to have in common across root command and subcommands.
   *
   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
   *
   * @param {Command} sourceCommand
   * @return {Command} `this` command for chaining
   */
  copyInheritedSettings(sourceCommand) {
    this._outputConfiguration = sourceCommand._outputConfiguration;
    this._helpOption = sourceCommand._helpOption;
    this._helpCommand = sourceCommand._helpCommand;
    this._helpConfiguration = sourceCommand._helpConfiguration;
    this._exitCallback = sourceCommand._exitCallback;
    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
    this._combineFlagAndOptionalValue =
      sourceCommand._combineFlagAndOptionalValue;
    this._allowExcessArguments = sourceCommand._allowExcessArguments;
    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
    this._showHelpAfterError = sourceCommand._showHelpAfterError;
    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;

    return this;
  }

  /**
   * @returns {Command[]}
   * @private
   */

  _getCommandAndAncestors() {
    const result = [];
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    for (let command = this; command; command = command.parent) {
      result.push(command);
    }
    return result;
  }

  /**
   * Define a command.
   *
   * There are two styles of command: pay attention to where to put the description.
   *
   * @example
   * // Command implemented using action handler (description is supplied separately to `.command`)
   * program
   *   .command('clone <source> [destination]')
   *   .description('clone a repository into a newly created directory')
   *   .action((source, destination) => {
   *     console.log('clone command called');
   *   });
   *
   * // Command implemented using separate executable file (description is second parameter to `.command`)
   * program
   *   .command('start <service>', 'start named service')
   *   .command('stop [service]', 'stop named service, or all if no name supplied');
   *
   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
   * @param {(object | string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
   * @param {object} [execOpts] - configuration options (for executable)
   * @return {Command} returns new command for action handler, or `this` for executable command
   */

  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
    let desc = actionOptsOrExecDesc;
    let opts = execOpts;
    if (typeof desc === 'object' && desc !== null) {
      opts = desc;
      desc = null;
    }
    opts = opts || {};
    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);

    const cmd = this.createCommand(name);
    if (desc) {
      cmd.description(desc);
      cmd._executableHandler = true;
    }
    if (opts.isDefault) this._defaultCommandName = cmd._name;
    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden
    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor
    if (args) cmd.arguments(args);
    this._registerCommand(cmd);
    cmd.parent = this;
    cmd.copyInheritedSettings(this);

    if (desc) return this;
    return cmd;
  }

  /**
   * Factory routine to create a new unattached command.
   *
   * See .command() for creating an attached subcommand, which uses this routine to
   * create the command. You can override createCommand to customise subcommands.
   *
   * @param {string} [name]
   * @return {Command} new command
   */

  createCommand(name) {
    return new Command(name);
  }

  /**
   * You can customise the help with a subclass of Help by overriding createHelp,
   * or by overriding Help properties using configureHelp().
   *
   * @return {Help}
   */

  createHelp() {
    return Object.assign(new Help(), this.configureHelp());
  }

  /**
   * You can customise the help by overriding Help properties using configureHelp(),
   * or with a subclass of Help by overriding createHelp().
   *
   * @param {object} [configuration] - configuration options
   * @return {(Command | object)} `this` command for chaining, or stored configuration
   */

  configureHelp(configuration) {
    if (configuration === undefined) return this._helpConfiguration;

    this._helpConfiguration = configuration;
    return this;
  }

  /**
   * The default output goes to stdout and stderr. You can customise this for special
   * applications. You can also customise the display of errors by overriding outputError.
   *
   * The configuration properties are all functions:
   *
   *     // change how output being written, defaults to stdout and stderr
   *     writeOut(str)
   *     writeErr(str)
   *     // change how output being written for errors, defaults to writeErr
   *     outputError(str, write) // used for displaying errors and not used for displaying help
   *     // specify width for wrapping help
   *     getOutHelpWidth()
   *     getErrHelpWidth()
   *     // color support, currently only used with Help
   *     getOutHasColors()
   *     getErrHasColors()
   *     stripColor() // used to remove ANSI escape codes if output does not have colors
   *
   * @param {object} [configuration] - configuration options
   * @return {(Command | object)} `this` command for chaining, or stored configuration
   */

  configureOutput(configuration) {
    if (configuration === undefined) return this._outputConfiguration;

    this._outputConfiguration = {
      ...this._outputConfiguration,
      ...configuration,
    };
    return this;
  }

  /**
   * Display the help or a custom message after an error occurs.
   *
   * @param {(boolean|string)} [displayHelp]
   * @return {Command} `this` command for chaining
   */
  showHelpAfterError(displayHelp = true) {
    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;
    this._showHelpAfterError = displayHelp;
    return this;
  }

  /**
   * Display suggestion of similar commands for unknown commands, or options for unknown options.
   *
   * @param {boolean} [displaySuggestion]
   * @return {Command} `this` command for chaining
   */
  showSuggestionAfterError(displaySuggestion = true) {
    this._showSuggestionAfterError = !!displaySuggestion;
    return this;
  }

  /**
   * Add a prepared subcommand.
   *
   * See .command() for creating an attached subcommand which inherits settings from its parent.
   *
   * @param {Command} cmd - new subcommand
   * @param {object} [opts] - configuration options
   * @return {Command} `this` command for chaining
   */

  addCommand(cmd, opts) {
    if (!cmd._name) {
      throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
    }

    opts = opts || {};
    if (opts.isDefault) this._defaultCommandName = cmd._name;
    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation

    this._registerCommand(cmd);
    cmd.parent = this;
    cmd._checkForBrokenPassThrough();

    return this;
  }

  /**
   * Factory routine to create a new unattached argument.
   *
   * See .argument() for creating an attached argument, which uses this routine to
   * create the argument. You can override createArgument to return a custom argument.
   *
   * @param {string} name
   * @param {string} [description]
   * @return {Argument} new argument
   */

  createArgument(name, description) {
    return new Argument(name, description);
  }

  /**
   * Define argument syntax for command.
   *
   * The default is that the argument is required, and you can explicitly
   * indicate this with <> around the name. Put [] around the name for an optional argument.
   *
   * @example
   * program.argument('<input-file>');
   * program.argument('[output-file]');
   *
   * @param {string} name
   * @param {string} [description]
   * @param {(Function|*)} [parseArg] - custom argument processing function or default value
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */
  argument(name, description, parseArg, defaultValue) {
    const argument = this.createArgument(name, description);
    if (typeof parseArg === 'function') {
      argument.default(defaultValue).argParser(parseArg);
    } else {
      argument.default(parseArg);
    }
    this.addArgument(argument);
    return this;
  }

  /**
   * Define argument syntax for command, adding multiple at once (without descriptions).
   *
   * See also .argument().
   *
   * @example
   * program.arguments('<cmd> [env]');
   *
   * @param {string} names
   * @return {Command} `this` command for chaining
   */

  arguments(names) {
    names
      .trim()
      .split(/ +/)
      .forEach((detail) => {
        this.argument(detail);
      });
    return this;
  }

  /**
   * Define argument syntax for command, adding a prepared argument.
   *
   * @param {Argument} argument
   * @return {Command} `this` command for chaining
   */
  addArgument(argument) {
    const previousArgument = this.registeredArguments.slice(-1)[0];
    if (previousArgument?.variadic) {
      throw new Error(
        `only the last argument can be variadic '${previousArgument.name()}'`,
      );
    }
    if (
      argument.required &&
      argument.defaultValue !== undefined &&
      argument.parseArg === undefined
    ) {
      throw new Error(
        `a default value for a required argument is never used: '${argument.name()}'`,
      );
    }
    this.registeredArguments.push(argument);
    return this;
  }

  /**
   * Customise or override default help command. By default a help command is automatically added if your command has subcommands.
   *
   * @example
   *    program.helpCommand('help [cmd]');
   *    program.helpCommand('help [cmd]', 'show help');
   *    program.helpCommand(false); // suppress default help command
   *    program.helpCommand(true); // add help command even if no subcommands
   *
   * @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added
   * @param {string} [description] - custom description
   * @return {Command} `this` command for chaining
   */

  helpCommand(enableOrNameAndArgs, description) {
    if (typeof enableOrNameAndArgs === 'boolean') {
      this._addImplicitHelpCommand = enableOrNameAndArgs;
      if (enableOrNameAndArgs && this._defaultCommandGroup) {
        // make the command to store the group
        this._initCommandGroup(this._getHelpCommand());
      }
      return this;
    }

    const nameAndArgs = enableOrNameAndArgs ?? 'help [command]';
    const [, helpName, helpArgs] = nameAndArgs.match(/([^ ]+) *(.*)/);
    const helpDescription = description ?? 'display help for command';

    const helpCommand = this.createCommand(helpName);
    helpCommand.helpOption(false);
    if (helpArgs) helpCommand.arguments(helpArgs);
    if (helpDescription) helpCommand.description(helpDescription);

    this._addImplicitHelpCommand = true;
    this._helpCommand = helpCommand;
    // init group unless lazy create
    if (enableOrNameAndArgs || description) this._initCommandGroup(helpCommand);

    return this;
  }

  /**
   * Add prepared custom help command.
   *
   * @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`
   * @param {string} [deprecatedDescription] - deprecated custom description used with custom name only
   * @return {Command} `this` command for chaining
   */
  addHelpCommand(helpCommand, deprecatedDescription) {
    // If not passed an object, call through to helpCommand for backwards compatibility,
    // as addHelpCommand was originally used like helpCommand is now.
    if (typeof helpCommand !== 'object') {
      this.helpCommand(helpCommand, deprecatedDescription);
      return this;
    }

    this._addImplicitHelpCommand = true;
    this._helpCommand = helpCommand;
    this._initCommandGroup(helpCommand);
    return this;
  }

  /**
   * Lazy create help command.
   *
   * @return {(Command|null)}
   * @package
   */
  _getHelpCommand() {
    const hasImplicitHelpCommand =
      this._addImplicitHelpCommand ??
      (this.commands.length &&
        !this._actionHandler &&
        !this._findCommand('help'));

    if (hasImplicitHelpCommand) {
      if (this._helpCommand === undefined) {
        this.helpCommand(undefined, undefined); // use default name and description
      }
      return this._helpCommand;
    }
    return null;
  }

  /**
   * Add hook for life cycle event.
   *
   * @param {string} event
   * @param {Function} listener
   * @return {Command} `this` command for chaining
   */

  hook(event, listener) {
    const allowedValues = ['preSubcommand', 'preAction', 'postAction'];
    if (!allowedValues.includes(event)) {
      throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
    }
    if (this._lifeCycleHooks[event]) {
      this._lifeCycleHooks[event].push(listener);
    } else {
      this._lifeCycleHooks[event] = [listener];
    }
    return this;
  }

  /**
   * Register callback to use as replacement for calling process.exit.
   *
   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
   * @return {Command} `this` command for chaining
   */

  exitOverride(fn) {
    if (fn) {
      this._exitCallback = fn;
    } else {
      this._exitCallback = (err) => {
        if (err.code !== 'commander.executeSubCommandAsync') {
          throw err;
        } else {
          // Async callback from spawn events, not useful to throw.
        }
      };
    }
    return this;
  }

  /**
   * Call process.exit, and _exitCallback if defined.
   *
   * @param {number} exitCode exit code for using with process.exit
   * @param {string} code an id string representing the error
   * @param {string} message human-readable description of the error
   * @return never
   * @private
   */

  _exit(exitCode, code, message) {
    if (this._exitCallback) {
      this._exitCallback(new CommanderError(exitCode, code, message));
      // Expecting this line is not reached.
    }
    process.exit(exitCode);
  }

  /**
   * Register callback `fn` for the command.
   *
   * @example
   * program
   *   .command('serve')
   *   .description('start service')
   *   .action(function() {
   *      // do work here
   *   });
   *
   * @param {Function} fn
   * @return {Command} `this` command for chaining
   */

  action(fn) {
    const listener = (args) => {
      // The .action callback takes an extra parameter which is the command or options.
      const expectedArgsCount = this.registeredArguments.length;
      const actionArgs = args.slice(0, expectedArgsCount);
      if (this._storeOptionsAsProperties) {
        actionArgs[expectedArgsCount] = this; // backwards compatible "options"
      } else {
        actionArgs[expectedArgsCount] = this.opts();
      }
      actionArgs.push(this);

      return fn.apply(this, actionArgs);
    };
    this._actionHandler = listener;
    return this;
  }

  /**
   * Factory routine to create a new unattached option.
   *
   * See .option() for creating an attached option, which uses this routine to
   * create the option. You can override createOption to return a custom option.
   *
   * @param {string} flags
   * @param {string} [description]
   * @return {Option} new option
   */

  createOption(flags, description) {
    return new Option(flags, description);
  }

  /**
   * Wrap parseArgs to catch 'commander.invalidArgument'.
   *
   * @param {(Option | Argument)} target
   * @param {string} value
   * @param {*} previous
   * @param {string} invalidArgumentMessage
   * @private
   */

  _callParseArg(target, value, previous, invalidArgumentMessage) {
    try {
      return target.parseArg(value, previous);
    } catch (err) {
      if (err.code === 'commander.invalidArgument') {
        const message = `${invalidArgumentMessage} ${err.message}`;
        this.error(message, { exitCode: err.exitCode, code: err.code });
      }
      throw err;
    }
  }

  /**
   * Check for option flag conflicts.
   * Register option if no conflicts found, or throw on conflict.
   *
   * @param {Option} option
   * @private
   */

  _registerOption(option) {
    const matchingOption =
      (option.short && this._findOption(option.short)) ||
      (option.long && this._findOption(option.long));
    if (matchingOption) {
      const matchingFlag =
        option.long && this._findOption(option.long)
          ? option.long
          : option.short;
      throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
    }

    this._initOptionGroup(option);
    this.options.push(option);
  }

  /**
   * Check for command name and alias conflicts with existing commands.
   * Register command if no conflicts found, or throw on conflict.
   *
   * @param {Command} command
   * @private
   */

  _registerCommand(command) {
    const knownBy = (cmd) => {
      return [cmd.name()].concat(cmd.aliases());
    };

    const alreadyUsed = knownBy(command).find((name) =>
      this._findCommand(name),
    );
    if (alreadyUsed) {
      const existingCmd = knownBy(this._findCommand(alreadyUsed)).join('|');
      const newCmd = knownBy(command).join('|');
      throw new Error(
        `cannot add command '${newCmd}' as already have command '${existingCmd}'`,
      );
    }

    this._initCommandGroup(command);
    this.commands.push(command);
  }

  /**
   * Add an option.
   *
   * @param {Option} option
   * @return {Command} `this` command for chaining
   */
  addOption(option) {
    this._registerOption(option);

    const oname = option.name();
    const name = option.attributeName();

    // store default value
    if (option.negate) {
      // --no-foo is special and defaults foo to true, unless a --foo option is already defined
      const positiveLongFlag = option.long.replace(/^--no-/, '--');
      if (!this._findOption(positiveLongFlag)) {
        this.setOptionValueWithSource(
          name,
          option.defaultValue === undefined ? true : option.defaultValue,
          'default',
        );
      }
    } else if (option.defaultValue !== undefined) {
      this.setOptionValueWithSource(name, option.defaultValue, 'default');
    }

    // handler for cli and env supplied values
    const handleOptionValue = (val, invalidValueMessage, valueSource) => {
      // val is null for optional option used without an optional-argument.
      // val is undefined for boolean and negated option.
      if (val == null && option.presetArg !== undefined) {
        val = option.presetArg;
      }

      // custom processing
      const oldValue = this.getOptionValue(name);
      if (val !== null && option.parseArg) {
        val = this._callParseArg(option, val, oldValue, invalidValueMessage);
      } else if (val !== null && option.variadic) {
        val = option._collectValue(val, oldValue);
      }

      // Fill-in appropriate missing values. Long winded but easy to follow.
      if (val == null) {
        if (option.negate) {
          val = false;
        } else if (option.isBoolean() || option.optional) {
          val = true;
        } else {
          val = ''; // not normal, parseArg might have failed or be a mock function for testing
        }
      }
      this.setOptionValueWithSource(name, val, valueSource);
    };

    this.on('option:' + oname, (val) => {
      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
      handleOptionValue(val, invalidValueMessage, 'cli');
    });

    if (option.envVar) {
      this.on('optionEnv:' + oname, (val) => {
        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
        handleOptionValue(val, invalidValueMessage, 'env');
      });
    }

    return this;
  }

  /**
   * Internal implementation shared by .option() and .requiredOption()
   *
   * @return {Command} `this` command for chaining
   * @private
   */
  _optionEx(config, flags, description, fn, defaultValue) {
    if (typeof flags === 'object' && flags instanceof Option) {
      throw new Error(
        'To add an Option object use addOption() instead of option() or requiredOption()',
      );
    }
    const option = this.createOption(flags, description);
    option.makeOptionMandatory(!!config.mandatory);
    if (typeof fn === 'function') {
      option.default(defaultValue).argParser(fn);
    } else if (fn instanceof RegExp) {
      // deprecated
      const regex = fn;
      fn = (val, def) => {
        const m = regex.exec(val);
        return m ? m[0] : def;
      };
      option.default(defaultValue).argParser(fn);
    } else {
      option.default(fn);
    }

    return this.addOption(option);
  }

  /**
   * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
   *
   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
   * option-argument is indicated by `<>` and an optional option-argument by `[]`.
   *
   * See the README for more details, and see also addOption() and requiredOption().
   *
   * @example
   * program
   *     .option('-p, --pepper', 'add pepper')
   *     .option('--pt, --pizza-type <TYPE>', 'type of pizza') // required option-argument
   *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
   *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
   *
   * @param {string} flags
   * @param {string} [description]
   * @param {(Function|*)} [parseArg] - custom option processing function or default value
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */

  option(flags, description, parseArg, defaultValue) {
    return this._optionEx({}, flags, description, parseArg, defaultValue);
  }

  /**
   * Add a required option which must have a value after parsing. This usually means
   * the option must be specified on the command line. (Otherwise the same as .option().)
   *
   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
   *
   * @param {string} flags
   * @param {string} [description]
   * @param {(Function|*)} [parseArg] - custom option processing function or default value
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */

  requiredOption(flags, description, parseArg, defaultValue) {
    return this._optionEx(
      { mandatory: true },
      flags,
      description,
      parseArg,
      defaultValue,
    );
  }

  /**
   * Alter parsing of short flags with optional values.
   *
   * @example
   * // for `.option('-f,--flag [value]'):
   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
   *
   * @param {boolean} [combine] - if `true` or omitted, an optional value can be specified directly after the flag.
   * @return {Command} `this` command for chaining
   */
  combineFlagAndOptionalValue(combine = true) {
    this._combineFlagAndOptionalValue = !!combine;
    return this;
  }

  /**
   * Allow unknown options on the command line.
   *
   * @param {boolean} [allowUnknown] - if `true` or omitted, no error will be thrown for unknown options.
   * @return {Command} `this` command for chaining
   */
  allowUnknownOption(allowUnknown = true) {
    this._allowUnknownOption = !!allowUnknown;
    return this;
  }

  /**
   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
   *
   * @param {boolean} [allowExcess] - if `true` or omitted, no error will be thrown for excess arguments.
   * @return {Command} `this` command for chaining
   */
  allowExcessArguments(allowExcess = true) {
    this._allowExcessArguments = !!allowExcess;
    return this;
  }

  /**
   * Enable positional options. Positional means global options are specified before subcommands which lets
   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
   * The default behaviour is non-positional and global options may appear anywhere on the command line.
   *
   * @param {boolean} [positional]
   * @return {Command} `this` command for chaining
   */
  enablePositionalOptions(positional = true) {
    this._enablePositionalOptions = !!positional;
    return this;
  }

  /**
   * Pass through options that come after command-arguments rather than treat them as command-options,
   * so actual command-options come before command-arguments. Turning this on for a subcommand requires
   * positional options to have been enabled on the program (parent commands).
   * The default behaviour is non-positional and options may appear before or after command-arguments.
   *
   * @param {boolean} [passThrough] for unknown options.
   * @return {Command} `this` command for chaining
   */
  passThroughOptions(passThrough = true) {
    this._passThroughOptions = !!passThrough;
    this._checkForBrokenPassThrough();
    return this;
  }

  /**
   * @private
   */

  _checkForBrokenPassThrough() {
    if (
      this.parent &&
      this._passThroughOptions &&
      !this.parent._enablePositionalOptions
    ) {
      throw new Error(
        `passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`,
      );
    }
  }

  /**
   * Whether to store option values as properties on command object,
   * or store separately (specify false). In both cases the option values can be accessed using .opts().
   *
   * @param {boolean} [storeAsProperties=true]
   * @return {Command} `this` command for chaining
   */

  storeOptionsAsProperties(storeAsProperties = true) {
    if (this.options.length) {
      throw new Error('call .storeOptionsAsProperties() before adding options');
    }
    if (Object.keys(this._optionValues).length) {
      throw new Error(
        'call .storeOptionsAsProperties() before setting option values',
      );
    }
    this._storeOptionsAsProperties = !!storeAsProperties;
    return this;
  }

  /**
   * Retrieve option value.
   *
   * @param {string} key
   * @return {object} value
   */

  getOptionValue(key) {
    if (this._storeOptionsAsProperties) {
      return this[key];
    }
    return this._optionValues[key];
  }

  /**
   * Store option value.
   *
   * @param {string} key
   * @param {object} value
   * @return {Command} `this` command for chaining
   */

  setOptionValue(key, value) {
    return this.setOptionValueWithSource(key, value, undefined);
  }

  /**
   * Store option value and where the value came from.
   *
   * @param {string} key
   * @param {object} value
   * @param {string} source - expected values are default/config/env/cli/implied
   * @return {Command} `this` command for chaining
   */

  setOptionValueWithSource(key, value, source) {
    if (this._storeOptionsAsProperties) {
      this[key] = value;
    } else {
      this._optionValues[key] = value;
    }
    this._optionValueSources[key] = source;
    return this;
  }

  /**
   * Get source of option value.
   * Expected values are default | config | env | cli | implied
   *
   * @param {string} key
   * @return {string}
   */

  getOptionValueSource(key) {
    return this._optionValueSources[key];
  }

  /**
   * Get source of option value. See also .optsWithGlobals().
   * Expected values are default | config | env | cli | implied
   *
   * @param {string} key
   * @return {string}
   */

  getOptionValueSourceWithGlobals(key) {
    // global overwrites local, like optsWithGlobals
    let source;
    this._getCommandAndAncestors().forEach((cmd) => {
      if (cmd.getOptionValueSource(key) !== undefined) {
        source = cmd.getOptionValueSource(key);
      }
    });
    return source;
  }

  /**
   * Get user arguments from implied or explicit arguments.
   * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
   *
   * @private
   */

  _prepareUserArgs(argv, parseOptions) {
    if (argv !== undefined && !Array.isArray(argv)) {
      throw new Error('first parameter to parse must be array or undefined');
    }
    parseOptions = parseOptions || {};

    // auto-detect argument conventions if nothing supplied
    if (argv === undefined && parseOptions.from === undefined) {
      if (process.versions?.electron) {
        parseOptions.from = 'electron';
      }
      // check node specific options for scenarios where user CLI args follow executable without scriptname
      const execArgv = process.execArgv ?? [];
      if (
        execArgv.includes('-e') ||
        execArgv.includes('--eval') ||
        execArgv.includes('-p') ||
        execArgv.includes('--print')
      ) {
        parseOptions.from = 'eval'; // internal usage, not documented
      }
    }

    // default to using process.argv
    if (argv === undefined) {
      argv = process.argv;
    }
    this.rawArgs = argv.slice();

    // extract the user args and scriptPath
    let userArgs;
    switch (parseOptions.from) {
      case undefined:
      case 'node':
        this._scriptPath = argv[1];
        userArgs = argv.slice(2);
        break;
      case 'electron':
        // @ts-ignore: because defaultApp is an unknown property
        if (process.defaultApp) {
          this._scriptPath = argv[1];
          userArgs = argv.slice(2);
        } else {
          userArgs = argv.slice(1);
        }
        break;
      case 'user':
        userArgs = argv.slice(0);
        break;
      case 'eval':
        userArgs = argv.slice(1);
        break;
      default:
        throw new Error(
          `unexpected parse option { from: '${parseOptions.from}' }`,
        );
    }

    // Find default name for program from arguments.
    if (!this._name && this._scriptPath)
      this.nameFromFilename(this._scriptPath);
    this._name = this._name || 'program';

    return userArgs;
  }

  /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * Use parseAsync instead of parse if any of your action handlers are async.
   *
   * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
   *
   * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
   * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
   * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
   * - `'user'`: just user arguments
   *
   * @example
   * program.parse(); // parse process.argv and auto-detect electron and special node flags
   * program.parse(process.argv); // assume argv[0] is app and argv[1] is script
   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]} [argv] - optional, defaults to process.argv
   * @param {object} [parseOptions] - optionally specify style of options with from: node/user/electron
   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
   * @return {Command} `this` command for chaining
   */

  parse(argv, parseOptions) {
    this._prepareForParse();
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    this._parseCommand([], userArgs);

    return this;
  }

  /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
   *
   * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
   * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
   * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
   * - `'user'`: just user arguments
   *
   * @example
   * await program.parseAsync(); // parse process.argv and auto-detect electron and special node flags
   * await program.parseAsync(process.argv); // assume argv[0] is app and argv[1] is script
   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]} [argv]
   * @param {object} [parseOptions]
   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
   * @return {Promise}
   */

  async parseAsync(argv, parseOptions) {
    this._prepareForParse();
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    await this._parseCommand([], userArgs);

    return this;
  }

  _prepareForParse() {
    if (this._savedState === null) {
      this.saveStateBeforeParse();
    } else {
      this.restoreStateBeforeParse();
    }
  }

  /**
   * Called the first time parse is called to save state and allow a restore before subsequent calls to parse.
   * Not usually called directly, but available for subclasses to save their custom state.
   *
   * This is called in a lazy way. Only commands used in parsing chain will have state saved.
   */
  saveStateBeforeParse() {
    this._savedState = {
      // name is stable if supplied by author, but may be unspecified for root command and deduced during parsing
      _name: this._name,
      // option values before parse have default values (including false for negated options)
      // shallow clones
      _optionValues: { ...this._optionValues },
      _optionValueSources: { ...this._optionValueSources },
    };
  }

  /**
   * Restore state before parse for calls after the first.
   * Not usually called directly, but available for subclasses to save their custom state.
   *
   * This is called in a lazy way. Only commands used in parsing chain will have state restored.
   */
  restoreStateBeforeParse() {
    if (this._storeOptionsAsProperties)
      throw new Error(`Can not call parse again when storeOptionsAsProperties is true.
- either make a new Command for each call to parse, or stop storing options as properties`);

    // clear state from _prepareUserArgs
    this._name = this._savedState._name;
    this._scriptPath = null;
    this.rawArgs = [];
    // clear state from setOptionValueWithSource
    this._optionValues = { ...this._savedState._optionValues };
    this._optionValueSources = { ...this._savedState._optionValueSources };
    // clear state from _parseCommand
    this.args = [];
    // clear state from _processArguments
    this.processedArgs = [];
  }

  /**
   * Throw if expected executable is missing. Add lots of help for author.
   *
   * @param {string} executableFile
   * @param {string} executableDir
   * @param {string} subcommandName
   */
  _checkForMissingExecutable(executableFile, executableDir, subcommandName) {
    if (fs.existsSync(executableFile)) return;

    const executableDirMessage = executableDir
      ? `searched for local subcommand relative to directory '${executableDir}'`
      : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';
    const executableMissing = `'${executableFile}' does not exist
 - if '${subcommandName}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
    throw new Error(executableMissing);
  }

  /**
   * Execute a sub-command executable.
   *
   * @private
   */

  _executeSubCommand(subcommand, args) {
    args = args.slice();
    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.
    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];

    function findFile(baseDir, baseName) {
      // Look for specified file
      const localBin = path.resolve(baseDir, baseName);
      if (fs.existsSync(localBin)) return localBin;

      // Stop looking if candidate already has an expected extension.
      if (sourceExt.includes(path.extname(baseName))) return undefined;

      // Try all the extensions.
      const foundExt = sourceExt.find((ext) =>
        fs.existsSync(`${localBin}${ext}`),
      );
      if (foundExt) return `${localBin}${foundExt}`;

      return undefined;
    }

    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.
    this._checkForMissingMandatoryOptions();
    this._checkForConflictingOptions();

    // executableFile and executableDir might be full path, or just a name
    let executableFile =
      subcommand._executableFile || `${this._name}-${subcommand._name}`;
    let executableDir = this._executableDir || '';
    if (this._scriptPath) {
      let resolvedScriptPath; // resolve possible symlink for installed npm binary
      try {
        resolvedScriptPath = fs.realpathSync(this._scriptPath);
      } catch {
        resolvedScriptPath = this._scriptPath;
      }
      executableDir = path.resolve(
        path.dirname(resolvedScriptPath),
        executableDir,
      );
    }

    // Look for a local file in preference to a command in PATH.
    if (executableDir) {
      let localFile = findFile(executableDir, executableFile);

      // Legacy search using prefix of script name instead of command name
      if (!localFile && !subcommand._executableFile && this._scriptPath) {
        const legacyName = path.basename(
          this._scriptPath,
          path.extname(this._scriptPath),
        );
        if (legacyName !== this._name) {
          localFile = findFile(
            executableDir,
            `${legacyName}-${subcommand._name}`,
          );
        }
      }
      executableFile = localFile || executableFile;
    }

    launchWithNode = sourceExt.includes(path.extname(executableFile));

    let proc;
    if (process.platform !== 'win32') {
      if (launchWithNode) {
        args.unshift(executableFile);
        // add executable arguments to spawn
        args = incrementNodeInspectorPort(process.execArgv).concat(args);

        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });
      } else {
        proc = childProcess.spawn(executableFile, args, { stdio: 'inherit' });
      }
    } else {
      this._checkForMissingExecutable(
        executableFile,
        executableDir,
        subcommand._name,
      );
      args.unshift(executableFile);
      // add executable arguments to spawn
      args = incrementNodeInspectorPort(process.execArgv).concat(args);
      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });
    }

    if (!proc.killed) {
      // testing mainly to avoid leak warnings during unit tests with mocked spawn
      const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
      signals.forEach((signal) => {
        process.on(signal, () => {
          if (proc.killed === false && proc.exitCode === null) {
            // @ts-ignore because signals not typed to known strings
            proc.kill(signal);
          }
        });
      });
    }

    // By default terminate process when spawned process terminates.
    const exitCallback = this._exitCallback;
    proc.on('close', (code) => {
      code = code ?? 1; // code is null if spawned process terminated due to a signal
      if (!exitCallback) {
        process.exit(code);
      } else {
        exitCallback(
          new CommanderError(
            code,
            'commander.executeSubCommandAsync',
            '(close)',
          ),
        );
      }
    });
    proc.on('error', (err) => {
      // @ts-ignore: because err.code is an unknown property
      if (err.code === 'ENOENT') {
        this._checkForMissingExecutable(
          executableFile,
          executableDir,
          subcommand._name,
        );
        // @ts-ignore: because err.code is an unknown property
      } else if (err.code === 'EACCES') {
        throw new Error(`'${executableFile}' not executable`);
      }
      if (!exitCallback) {
        process.exit(1);
      } else {
        const wrappedError = new CommanderError(
          1,
          'commander.executeSubCommandAsync',
          '(error)',
        );
        wrappedError.nestedError = err;
        exitCallback(wrappedError);
      }
    });

    // Store the reference to the child process
    this.runningCommand = proc;
  }

  /**
   * @private
   */

  _dispatchSubcommand(commandName, operands, unknown) {
    const subCommand = this._findCommand(commandName);
    if (!subCommand) this.help({ error: true });

    subCommand._prepareForParse();
    let promiseChain;
    promiseChain = this._chainOrCallSubCommandHook(
      promiseChain,
      subCommand,
      'preSubcommand',
    );
    promiseChain = this._chainOrCall(promiseChain, () => {
      if (subCommand._executableHandler) {
        this._executeSubCommand(subCommand, operands.concat(unknown));
      } else {
        return subCommand._parseCommand(operands, unknown);
      }
    });
    return promiseChain;
  }

  /**
   * Invoke help directly if possible, or dispatch if necessary.
   * e.g. help foo
   *
   * @private
   */

  _dispatchHelpCommand(subcommandName) {
    if (!subcommandName) {
      this.help();
    }
    const subCommand = this._findCommand(subcommandName);
    if (subCommand && !subCommand._executableHandler) {
      subCommand.help();
    }

    // Fallback to parsing the help flag to invoke the help.
    return this._dispatchSubcommand(
      subcommandName,
      [],
      [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? '--help'],
    );
  }

  /**
   * Check this.args against expected this.registeredArguments.
   *
   * @private
   */

  _checkNumberOfArguments() {
    // too few
    this.registeredArguments.forEach((arg, i) => {
      if (arg.required && this.args[i] == null) {
        this.missingArgument(arg.name());
      }
    });
    // too many
    if (
      this.registeredArguments.length > 0 &&
      this.registeredArguments[this.registeredArguments.length - 1].variadic
    ) {
      return;
    }
    if (this.args.length > this.registeredArguments.length) {
      this._excessArguments(this.args);
    }
  }

  /**
   * Process this.args using this.registeredArguments and save as this.processedArgs!
   *
   * @private
   */

  _processArguments() {
    const myParseArg = (argument, value, previous) => {
      // Extra processing for nice error message on parsing failure.
      let parsedValue = value;
      if (value !== null && argument.parseArg) {
        const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
        parsedValue = this._callParseArg(
          argument,
          value,
          previous,
          invalidValueMessage,
        );
      }
      return parsedValue;
    };

    this._checkNumberOfArguments();

    const processedArgs = [];
    this.registeredArguments.forEach((declaredArg, index) => {
      let value = declaredArg.defaultValue;
      if (declaredArg.variadic) {
        // Collect together remaining arguments for passing together as an array.
        if (index < this.args.length) {
          value = this.args.slice(index);
          if (declaredArg.parseArg) {
            value = value.reduce((processed, v) => {
              return myParseArg(declaredArg, v, processed);
            }, declaredArg.defaultValue);
          }
        } else if (value === undefined) {
          value = [];
        }
      } else if (index < this.args.length) {
        value = this.args[index];
        if (declaredArg.parseArg) {
          value = myParseArg(declaredArg, value, declaredArg.defaultValue);
        }
      }
      processedArgs[index] = value;
    });
    this.processedArgs = processedArgs;
  }

  /**
   * Once we have a promise we chain, but call synchronously until then.
   *
   * @param {(Promise|undefined)} promise
   * @param {Function} fn
   * @return {(Promise|undefined)}
   * @private
   */

  _chainOrCall(promise, fn) {
    // thenable
    if (promise?.then && typeof promise.then === 'function') {
      // already have a promise, chain callback
      return promise.then(() => fn());
    }
    // callback might return a promise
    return fn();
  }

  /**
   *
   * @param {(Promise|undefined)} promise
   * @param {string} event
   * @return {(Promise|undefined)}
   * @private
   */

  _chainOrCallHooks(promise, event) {
    let result = promise;
    const hooks = [];
    this._getCommandAndAncestors()
      .reverse()
      .filter((cmd) => cmd._lifeCycleHooks[event] !== undefined)
      .forEach((hookedCommand) => {
        hookedCommand._lifeCycleHooks[event].forEach((callback) => {
          hooks.push({ hookedCommand, callback });
        });
      });
    if (event === 'postAction') {
      hooks.reverse();
    }

    hooks.forEach((hookDetail) => {
      result = this._chainOrCall(result, () => {
        return hookDetail.callback(hookDetail.hookedCommand, this);
      });
    });
    return result;
  }

  /**
   *
   * @param {(Promise|undefined)} promise
   * @param {Command} subCommand
   * @param {string} event
   * @return {(Promise|undefined)}
   * @private
   */

  _chainOrCallSubCommandHook(promise, subCommand, event) {
    let result = promise;
    if (this._lifeCycleHooks[event] !== undefined) {
      this._lifeCycleHooks[event].forEach((hook) => {
        result = this._chainOrCall(result, () => {
          return hook(this, subCommand);
        });
      });
    }
    return result;
  }

  /**
   * Process arguments in context of this command.
   * Returns action result, in case it is a promise.
   *
   * @private
   */

  _parseCommand(operands, unknown) {
    const parsed = this.parseOptions(unknown);
    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env
    this._parseOptionsImplied();
    operands = operands.concat(parsed.operands);
    unknown = parsed.unknown;
    this.args = operands.concat(unknown);

    if (operands && this._findCommand(operands[0])) {
      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
    }
    if (
      this._getHelpCommand() &&
      operands[0] === this._getHelpCommand().name()
    ) {
      return this._dispatchHelpCommand(operands[1]);
    }
    if (this._defaultCommandName) {
      this._outputHelpIfRequested(unknown); // Run the help for default command from parent rather than passing to default command
      return this._dispatchSubcommand(
        this._defaultCommandName,
        operands,
        unknown,
      );
    }
    if (
      this.commands.length &&
      this.args.length === 0 &&
      !this._actionHandler &&
      !this._defaultCommandName
    ) {
      // probably missing subcommand and no handler, user needs help (and exit)
      this.help({ error: true });
    }

    this._outputHelpIfRequested(parsed.unknown);
    this._checkForMissingMandatoryOptions();
    this._checkForConflictingOptions();

    // We do not always call this check to avoid masking a "better" error, like unknown command.
    const checkForUnknownOptions = () => {
      if (parsed.unknown.length > 0) {
        this.unknownOption(parsed.unknown[0]);
      }
    };

    const commandEvent = `command:${this.name()}`;
    if (this._actionHandler) {
      checkForUnknownOptions();
      this._processArguments();

      let promiseChain;
      promiseChain = this._chainOrCallHooks(promiseChain, 'preAction');
      promiseChain = this._chainOrCall(promiseChain, () =>
        this._actionHandler(this.processedArgs),
      );
      if (this.parent) {
        promiseChain = this._chainOrCall(promiseChain, () => {
          this.parent.emit(commandEvent, operands, unknown); // legacy
        });
      }
      promiseChain = this._chainOrCallHooks(promiseChain, 'postAction');
      return promiseChain;
    }
    if (this.parent?.listenerCount(commandEvent)) {
      checkForUnknownOptions();
      this._processArguments();
      this.parent.emit(commandEvent, operands, unknown); // legacy
    } else if (operands.length) {
      if (this._findCommand('*')) {
        // legacy default command
        return this._dispatchSubcommand('*', operands, unknown);
      }
      if (this.listenerCount('command:*')) {
        // skip option check, emit event for possible misspelling suggestion
        this.emit('command:*', operands, unknown);
      } else if (this.commands.length) {
        this.unknownCommand();
      } else {
        checkForUnknownOptions();
        this._processArguments();
      }
    } else if (this.commands.length) {
      checkForUnknownOptions();
      // This command has subcommands and nothing hooked up at this level, so display help (and exit).
      this.help({ error: true });
    } else {
      checkForUnknownOptions();
      this._processArguments();
      // fall through for caller to handle after calling .parse()
    }
  }

  /**
   * Find matching command.
   *
   * @private
   * @return {Command | undefined}
   */
  _findCommand(name) {
    if (!name) return undefined;
    return this.commands.find(
      (cmd) => cmd._name === name || cmd._aliases.includes(name),
    );
  }

  /**
   * Return an option matching `arg` if any.
   *
   * @param {string} arg
   * @return {Option}
   * @package
   */

  _findOption(arg) {
    return this.options.find((option) => option.is(arg));
  }

  /**
   * Display an error message if a mandatory option does not have a value.
   * Called after checking for help flags in leaf subcommand.
   *
   * @private
   */

  _checkForMissingMandatoryOptions() {
    // Walk up hierarchy so can call in subcommand after checking for displaying help.
    this._getCommandAndAncestors().forEach((cmd) => {
      cmd.options.forEach((anOption) => {
        if (
          anOption.mandatory &&
          cmd.getOptionValue(anOption.attributeName()) === undefined
        ) {
          cmd.missingMandatoryOptionValue(anOption);
        }
      });
    });
  }

  /**
   * Display an error message if conflicting options are used together in this.
   *
   * @private
   */
  _checkForConflictingLocalOptions() {
    const definedNonDefaultOptions = this.options.filter((option) => {
      const optionKey = option.attributeName();
      if (this.getOptionValue(optionKey) === undefined) {
        return false;
      }
      return this.getOptionValueSource(optionKey) !== 'default';
    });

    const optionsWithConflicting = definedNonDefaultOptions.filter(
      (option) => option.conflictsWith.length > 0,
    );

    optionsWithConflicting.forEach((option) => {
      const conflictingAndDefined = definedNonDefaultOptions.find((defined) =>
        option.conflictsWith.includes(defined.attributeName()),
      );
      if (conflictingAndDefined) {
        this._conflictingOption(option, conflictingAndDefined);
      }
    });
  }

  /**
   * Display an error message if conflicting options are used together.
   * Called after checking for help flags in leaf subcommand.
   *
   * @private
   */
  _checkForConflictingOptions() {
    // Walk up hierarchy so can call in subcommand after checking for displaying help.
    this._getCommandAndAncestors().forEach((cmd) => {
      cmd._checkForConflictingLocalOptions();
    });
  }

  /**
   * Parse options from `argv` removing known options,
   * and return argv split into operands and unknown arguments.
   *
   * Side effects: modifies command by storing options. Does not reset state if called again.
   *
   * Examples:
   *
   *     argv => operands, unknown
   *     --known kkk op => [op], []
   *     op --known kkk => [op], []
   *     sub --unknown uuu op => [sub], [--unknown uuu op]
   *     sub -- --unknown uuu op => [sub --unknown uuu op], []
   *
   * @param {string[]} args
   * @return {{operands: string[], unknown: string[]}}
   */

  parseOptions(args) {
    const operands = []; // operands, not options or values
    const unknown = []; // first unknown option and remaining unknown args
    let dest = operands;

    function maybeOption(arg) {
      return arg.length > 1 && arg[0] === '-';
    }

    const negativeNumberArg = (arg) => {
      // return false if not a negative number
      if (!/^-(\d+|\d*\.\d+)(e[+-]?\d+)?$/.test(arg)) return false;
      // negative number is ok unless digit used as an option in command hierarchy
      return !this._getCommandAndAncestors().some((cmd) =>
        cmd.options
          .map((opt) => opt.short)
          .some((short) => /^-\d$/.test(short)),
      );
    };

    // parse options
    let activeVariadicOption = null;
    let activeGroup = null; // working through group of short options, like -abc
    let i = 0;
    while (i < args.length || activeGroup) {
      const arg = activeGroup ?? args[i++];
      activeGroup = null;

      // literal
      if (arg === '--') {
        if (dest === unknown) dest.push(arg);
        dest.push(...args.slice(i));
        break;
      }

      if (
        activeVariadicOption &&
        (!maybeOption(arg) || negativeNumberArg(arg))
      ) {
        this.emit(`option:${activeVariadicOption.name()}`, arg);
        continue;
      }
      activeVariadicOption = null;

      if (maybeOption(arg)) {
        const option = this._findOption(arg);
        // recognised option, call listener to assign value with possible custom processing
        if (option) {
          if (option.required) {
            const value = args[i++];
            if (value === undefined) this.optionMissingArgument(option);
            this.emit(`option:${option.name()}`, value);
          } else if (option.optional) {
            let value = null;
            // historical behaviour is optional value is following arg unless an option
            if (
              i < args.length &&
              (!maybeOption(args[i]) || negativeNumberArg(args[i]))
            ) {
              value = args[i++];
            }
            this.emit(`option:${option.name()}`, value);
          } else {
            // boolean flag
            this.emit(`option:${option.name()}`);
          }
          activeVariadicOption = option.variadic ? option : null;
          continue;
        }
      }

      // Look for combo options following single dash, eat first one if known.
      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
        const option = this._findOption(`-${arg[1]}`);
        if (option) {
          if (
            option.required ||
            (option.optional && this._combineFlagAndOptionalValue)
          ) {
            // option with value following in same argument
            this.emit(`option:${option.name()}`, arg.slice(2));
          } else {
            // boolean option
            this.emit(`option:${option.name()}`);
            // remove the processed option and keep processing group
            activeGroup = `-${arg.slice(2)}`;
          }
          continue;
        }
      }

      // Look for known long flag with value, like --foo=bar
      if (/^--[^=]+=/.test(arg)) {
        const index = arg.indexOf('=');
        const option = this._findOption(arg.slice(0, index));
        if (option && (option.required || option.optional)) {
          this.emit(`option:${option.name()}`, arg.slice(index + 1));
          continue;
        }
      }

      // Not a recognised option by this command.
      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.

      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.
      // A negative number in a leaf command is not an unknown option.
      if (
        dest === operands &&
        maybeOption(arg) &&
        !(this.commands.length === 0 && negativeNumberArg(arg))
      ) {
        dest = unknown;
      }

      // If using positionalOptions, stop processing our options at subcommand.
      if (
        (this._enablePositionalOptions || this._passThroughOptions) &&
        operands.length === 0 &&
        unknown.length === 0
      ) {
        if (this._findCommand(arg)) {
          operands.push(arg);
          unknown.push(...args.slice(i));
          break;
        } else if (
          this._getHelpCommand() &&
          arg === this._getHelpCommand().name()
        ) {
          operands.push(arg, ...args.slice(i));
          break;
        } else if (this._defaultCommandName) {
          unknown.push(arg, ...args.slice(i));
          break;
        }
      }

      // If using passThroughOptions, stop processing options at first command-argument.
      if (this._passThroughOptions) {
        dest.push(arg, ...args.slice(i));
        break;
      }

      // add arg
      dest.push(arg);
    }

    return { operands, unknown };
  }

  /**
   * Return an object containing local option values as key-value pairs.
   *
   * @return {object}
   */
  opts() {
    if (this._storeOptionsAsProperties) {
      // Preserve original behaviour so backwards compatible when still using properties
      const result = {};
      const len = this.options.length;

      for (let i = 0; i < len; i++) {
        const key = this.options[i].attributeName();
        result[key] =
          key === this._versionOptionName ? this._version : this[key];
      }
      return result;
    }

    return this._optionValues;
  }

  /**
   * Return an object containing merged local and global option values as key-value pairs.
   *
   * @return {object}
   */
  optsWithGlobals() {
    // globals overwrite locals
    return this._getCommandAndAncestors().reduce(
      (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
      {},
    );
  }

  /**
   * Display error message and exit (or call exitOverride).
   *
   * @param {string} message
   * @param {object} [errorOptions]
   * @param {string} [errorOptions.code] - an id string representing the error
   * @param {number} [errorOptions.exitCode] - used with process.exit
   */
  error(message, errorOptions) {
    // output handling
    this._outputConfiguration.outputError(
      `${message}\n`,
      this._outputConfiguration.writeErr,
    );
    if (typeof this._showHelpAfterError === 'string') {
      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`);
    } else if (this._showHelpAfterError) {
      this._outputConfiguration.writeErr('\n');
      this.outputHelp({ error: true });
    }

    // exit handling
    const config = errorOptions || {};
    const exitCode = config.exitCode || 1;
    const code = config.code || 'commander.error';
    this._exit(exitCode, code, message);
  }

  /**
   * Apply any option related environment variables, if option does
   * not have a value from cli or client code.
   *
   * @private
   */
  _parseOptionsEnv() {
    this.options.forEach((option) => {
      if (option.envVar && option.envVar in process.env) {
        const optionKey = option.attributeName();
        // Priority check. Do not overwrite cli or options from unknown source (client-code).
        if (
          this.getOptionValue(optionKey) === undefined ||
          ['default', 'config', 'env'].includes(
            this.getOptionValueSource(optionKey),
          )
        ) {
          if (option.required || option.optional) {
            // option can take a value
            // keep very simple, optional always takes value
            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);
          } else {
            // boolean
            // keep very simple, only care that envVar defined and not the value
            this.emit(`optionEnv:${option.name()}`);
          }
        }
      }
    });
  }

  /**
   * Apply any implied option values, if option is undefined or default value.
   *
   * @private
   */
  _parseOptionsImplied() {
    const dualHelper = new DualOptions(this.options);
    const hasCustomOptionValue = (optionKey) => {
      return (
        this.getOptionValue(optionKey) !== undefined &&
        !['default', 'implied'].includes(this.getOptionValueSource(optionKey))
      );
    };
    this.options
      .filter(
        (option) =>
          option.implied !== undefined &&
          hasCustomOptionValue(option.attributeName()) &&
          dualHelper.valueFromOption(
            this.getOptionValue(option.attributeName()),
            option,
          ),
      )
      .forEach((option) => {
        Object.keys(option.implied)
          .filter((impliedKey) => !hasCustomOptionValue(impliedKey))
          .forEach((impliedKey) => {
            this.setOptionValueWithSource(
              impliedKey,
              option.implied[impliedKey],
              'implied',
            );
          });
      });
  }

  /**
   * Argument `name` is missing.
   *
   * @param {string} name
   * @private
   */

  missingArgument(name) {
    const message = `error: missing required argument '${name}'`;
    this.error(message, { code: 'commander.missingArgument' });
  }

  /**
   * `Option` is missing an argument.
   *
   * @param {Option} option
   * @private
   */

  optionMissingArgument(option) {
    const message = `error: option '${option.flags}' argument missing`;
    this.error(message, { code: 'commander.optionMissingArgument' });
  }

  /**
   * `Option` does not have a value, and is a mandatory option.
   *
   * @param {Option} option
   * @private
   */

  missingMandatoryOptionValue(option) {
    const message = `error: required option '${option.flags}' not specified`;
    this.error(message, { code: 'commander.missingMandatoryOptionValue' });
  }

  /**
   * `Option` conflicts with another option.
   *
   * @param {Option} option
   * @param {Option} conflictingOption
   * @private
   */
  _conflictingOption(option, conflictingOption) {
    // The calling code does not know whether a negated option is the source of the
    // value, so do some work to take an educated guess.
    const findBestOptionFromValue = (option) => {
      const optionKey = option.attributeName();
      const optionValue = this.getOptionValue(optionKey);
      const negativeOption = this.options.find(
        (target) => target.negate && optionKey === target.attributeName(),
      );
      const positiveOption = this.options.find(
        (target) => !target.negate && optionKey === target.attributeName(),
      );
      if (
        negativeOption &&
        ((negativeOption.presetArg === undefined && optionValue === false) ||
          (negativeOption.presetArg !== undefined &&
            optionValue === negativeOption.presetArg))
      ) {
        return negativeOption;
      }
      return positiveOption || option;
    };

    const getErrorMessage = (option) => {
      const bestOption = findBestOptionFromValue(option);
      const optionKey = bestOption.attributeName();
      const source = this.getOptionValueSource(optionKey);
      if (source === 'env') {
        return `environment variable '${bestOption.envVar}'`;
      }
      return `option '${bestOption.flags}'`;
    };

    const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
    this.error(message, { code: 'commander.conflictingOption' });
  }

  /**
   * Unknown option `flag`.
   *
   * @param {string} flag
   * @private
   */

  unknownOption(flag) {
    if (this._allowUnknownOption) return;
    let suggestion = '';

    if (flag.startsWith('--') && this._showSuggestionAfterError) {
      // Looping to pick up the global options too
      let candidateFlags = [];
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      let command = this;
      do {
        const moreFlags = command
          .createHelp()
          .visibleOptions(command)
          .filter((option) => option.long)
          .map((option) => option.long);
        candidateFlags = candidateFlags.concat(moreFlags);
        command = command.parent;
      } while (command && !command._enablePositionalOptions);
      suggestion = suggestSimilar(flag, candidateFlags);
    }

    const message = `error: unknown option '${flag}'${suggestion}`;
    this.error(message, { code: 'commander.unknownOption' });
  }

  /**
   * Excess arguments, more than expected.
   *
   * @param {string[]} receivedArgs
   * @private
   */

  _excessArguments(receivedArgs) {
    if (this._allowExcessArguments) return;

    const expected = this.registeredArguments.length;
    const s = expected === 1 ? '' : 's';
    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';
    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
    this.error(message, { code: 'commander.excessArguments' });
  }

  /**
   * Unknown command.
   *
   * @private
   */

  unknownCommand() {
    const unknownName = this.args[0];
    let suggestion = '';

    if (this._showSuggestionAfterError) {
      const candidateNames = [];
      this.createHelp()
        .visibleCommands(this)
        .forEach((command) => {
          candidateNames.push(command.name());
          // just visible alias
          if (command.alias()) candidateNames.push(command.alias());
        });
      suggestion = suggestSimilar(unknownName, candidateNames);
    }

    const message = `error: unknown command '${unknownName}'${suggestion}`;
    this.error(message, { code: 'commander.unknownCommand' });
  }

  /**
   * Get or set the program version.
   *
   * This method auto-registers the "-V, --version" option which will print the version number.
   *
   * You can optionally supply the flags and description to override the defaults.
   *
   * @param {string} [str]
   * @param {string} [flags]
   * @param {string} [description]
   * @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments
   */

  version(str, flags, description) {
    if (str === undefined) return this._version;
    this._version = str;
    flags = flags || '-V, --version';
    description = description || 'output the version number';
    const versionOption = this.createOption(flags, description);
    this._versionOptionName = versionOption.attributeName();
    this._registerOption(versionOption);

    this.on('option:' + versionOption.name(), () => {
      this._outputConfiguration.writeOut(`${str}\n`);
      this._exit(0, 'commander.version', str);
    });
    return this;
  }

  /**
   * Set the description.
   *
   * @param {string} [str]
   * @param {object} [argsDescription]
   * @return {(string|Command)}
   */
  description(str, argsDescription) {
    if (str === undefined && argsDescription === undefined)
      return this._description;
    this._description = str;
    if (argsDescription) {
      this._argsDescription = argsDescription;
    }
    return this;
  }

  /**
   * Set the summary. Used when listed as subcommand of parent.
   *
   * @param {string} [str]
   * @return {(string|Command)}
   */
  summary(str) {
    if (str === undefined) return this._summary;
    this._summary = str;
    return this;
  }

  /**
   * Set an alias for the command.
   *
   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
   *
   * @param {string} [alias]
   * @return {(string|Command)}
   */

  alias(alias) {
    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility

    /** @type {Command} */
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    let command = this;
    if (
      this.commands.length !== 0 &&
      this.commands[this.commands.length - 1]._executableHandler
    ) {
      // assume adding alias for last added executable subcommand, rather than this
      command = this.commands[this.commands.length - 1];
    }

    if (alias === command._name)
      throw new Error("Command alias can't be the same as its name");
    const matchingCommand = this.parent?._findCommand(alias);
    if (matchingCommand) {
      // c.f. _registerCommand
      const existingCmd = [matchingCommand.name()]
        .concat(matchingCommand.aliases())
        .join('|');
      throw new Error(
        `cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`,
      );
    }

    command._aliases.push(alias);
    return this;
  }

  /**
   * Set aliases for the command.
   *
   * Only the first alias is shown in the auto-generated help.
   *
   * @param {string[]} [aliases]
   * @return {(string[]|Command)}
   */

  aliases(aliases) {
    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().
    if (aliases === undefined) return this._aliases;

    aliases.forEach((alias) => this.alias(alias));
    return this;
  }

  /**
   * Set / get the command usage `str`.
   *
   * @param {string} [str]
   * @return {(string|Command)}
   */

  usage(str) {
    if (str === undefined) {
      if (this._usage) return this._usage;

      const args = this.registeredArguments.map((arg) => {
        return humanReadableArgName(arg);
      });
      return []
        .concat(
          this.options.length || this._helpOption !== null ? '[options]' : [],
          this.commands.length ? '[command]' : [],
          this.registeredArguments.length ? args : [],
        )
        .join(' ');
    }

    this._usage = str;
    return this;
  }

  /**
   * Get or set the name of the command.
   *
   * @param {string} [str]
   * @return {(string|Command)}
   */

  name(str) {
    if (str === undefined) return this._name;
    this._name = str;
    return this;
  }

  /**
   * Set/get the help group heading for this subcommand in parent command's help.
   *
   * @param {string} [heading]
   * @return {Command | string}
   */

  helpGroup(heading) {
    if (heading === undefined) return this._helpGroupHeading ?? '';
    this._helpGroupHeading = heading;
    return this;
  }

  /**
   * Set/get the default help group heading for subcommands added to this command.
   * (This does not override a group set directly on the subcommand using .helpGroup().)
   *
   * @example
   * program.commandsGroup('Development Commands:);
   * program.command('watch')...
   * program.command('lint')...
   * ...
   *
   * @param {string} [heading]
   * @returns {Command | string}
   */
  commandsGroup(heading) {
    if (heading === undefined) return this._defaultCommandGroup ?? '';
    this._defaultCommandGroup = heading;
    return this;
  }

  /**
   * Set/get the default help group heading for options added to this command.
   * (This does not override a group set directly on the option using .helpGroup().)
   *
   * @example
   * program
   *   .optionsGroup('Development Options:')
   *   .option('-d, --debug', 'output extra debugging')
   *   .option('-p, --profile', 'output profiling information')
   *
   * @param {string} [heading]
   * @returns {Command | string}
   */
  optionsGroup(heading) {
    if (heading === undefined) return this._defaultOptionGroup ?? '';
    this._defaultOptionGroup = heading;
    return this;
  }

  /**
   * @param {Option} option
   * @private
   */
  _initOptionGroup(option) {
    if (this._defaultOptionGroup && !option.helpGroupHeading)
      option.helpGroup(this._defaultOptionGroup);
  }

  /**
   * @param {Command} cmd
   * @private
   */
  _initCommandGroup(cmd) {
    if (this._defaultCommandGroup && !cmd.helpGroup())
      cmd.helpGroup(this._defaultCommandGroup);
  }

  /**
   * Set the name of the command from script filename, such as process.argv[1],
   * or require.main.filename, or __filename.
   *
   * (Used internally and public although not documented in README.)
   *
   * @example
   * program.nameFromFilename(require.main.filename);
   *
   * @param {string} filename
   * @return {Command}
   */

  nameFromFilename(filename) {
    this._name = path.basename(filename, path.extname(filename));

    return this;
  }

  /**
   * Get or set the directory for searching for executable subcommands of this command.
   *
   * @example
   * program.executableDir(__dirname);
   * // or
   * program.executableDir('subcommands');
   *
   * @param {string} [path]
   * @return {(string|null|Command)}
   */

  executableDir(path) {
    if (path === undefined) return this._executableDir;
    this._executableDir = path;
    return this;
  }

  /**
   * Return program help documentation.
   *
   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
   * @return {string}
   */

  helpInformation(contextOptions) {
    const helper = this.createHelp();
    const context = this._getOutputContext(contextOptions);
    helper.prepareContext({
      error: context.error,
      helpWidth: context.helpWidth,
      outputHasColors: context.hasColors,
    });
    const text = helper.formatHelp(this, helper);
    if (context.hasColors) return text;
    return this._outputConfiguration.stripColor(text);
  }

  /**
   * @typedef HelpContext
   * @type {object}
   * @property {boolean} error
   * @property {number} helpWidth
   * @property {boolean} hasColors
   * @property {function} write - includes stripColor if needed
   *
   * @returns {HelpContext}
   * @private
   */

  _getOutputContext(contextOptions) {
    contextOptions = contextOptions || {};
    const error = !!contextOptions.error;
    let baseWrite;
    let hasColors;
    let helpWidth;
    if (error) {
      baseWrite = (str) => this._outputConfiguration.writeErr(str);
      hasColors = this._outputConfiguration.getErrHasColors();
      helpWidth = this._outputConfiguration.getErrHelpWidth();
    } else {
      baseWrite = (str) => this._outputConfiguration.writeOut(str);
      hasColors = this._outputConfiguration.getOutHasColors();
      helpWidth = this._outputConfiguration.getOutHelpWidth();
    }
    const write = (str) => {
      if (!hasColors) str = this._outputConfiguration.stripColor(str);
      return baseWrite(str);
    };
    return { error, write, hasColors, helpWidth };
  }

  /**
   * Output help information for this command.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
   */

  outputHelp(contextOptions) {
    let deprecatedCallback;
    if (typeof contextOptions === 'function') {
      deprecatedCallback = contextOptions;
      contextOptions = undefined;
    }

    const outputContext = this._getOutputContext(contextOptions);
    /** @type {HelpTextEventContext} */
    const eventContext = {
      error: outputContext.error,
      write: outputContext.write,
      command: this,
    };

    this._getCommandAndAncestors()
      .reverse()
      .forEach((command) => command.emit('beforeAllHelp', eventContext));
    this.emit('beforeHelp', eventContext);

    let helpInformation = this.helpInformation({ error: outputContext.error });
    if (deprecatedCallback) {
      helpInformation = deprecatedCallback(helpInformation);
      if (
        typeof helpInformation !== 'string' &&
        !Buffer.isBuffer(helpInformation)
      ) {
        throw new Error('outputHelp callback must return a string or a Buffer');
      }
    }
    outputContext.write(helpInformation);

    if (this._getHelpOption()?.long) {
      this.emit(this._getHelpOption().long); // deprecated
    }
    this.emit('afterHelp', eventContext);
    this._getCommandAndAncestors().forEach((command) =>
      command.emit('afterAllHelp', eventContext),
    );
  }

  /**
   * You can pass in flags and a description to customise the built-in help option.
   * Pass in false to disable the built-in help option.
   *
   * @example
   * program.helpOption('-?, --help' 'show help'); // customise
   * program.helpOption(false); // disable
   *
   * @param {(string | boolean)} flags
   * @param {string} [description]
   * @return {Command} `this` command for chaining
   */

  helpOption(flags, description) {
    // Support enabling/disabling built-in help option.
    if (typeof flags === 'boolean') {
      if (flags) {
        if (this._helpOption === null) this._helpOption = undefined; // reenable
        if (this._defaultOptionGroup) {
          // make the option to store the group
          this._initOptionGroup(this._getHelpOption());
        }
      } else {
        this._helpOption = null; // disable
      }
      return this;
    }

    // Customise flags and description.
    this._helpOption = this.createOption(
      flags ?? '-h, --help',
      description ?? 'display help for command',
    );
    // init group unless lazy create
    if (flags || description) this._initOptionGroup(this._helpOption);

    return this;
  }

  /**
   * Lazy create help option.
   * Returns null if has been disabled with .helpOption(false).
   *
   * @returns {(Option | null)} the help option
   * @package
   */
  _getHelpOption() {
    // Lazy create help option on demand.
    if (this._helpOption === undefined) {
      this.helpOption(undefined, undefined);
    }
    return this._helpOption;
  }

  /**
   * Supply your own option to use for the built-in help option.
   * This is an alternative to using helpOption() to customise the flags and description etc.
   *
   * @param {Option} option
   * @return {Command} `this` command for chaining
   */
  addHelpOption(option) {
    this._helpOption = option;
    this._initOptionGroup(option);
    return this;
  }

  /**
   * Output help information and exit.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
   */

  help(contextOptions) {
    this.outputHelp(contextOptions);
    let exitCode = Number(process.exitCode ?? 0); // process.exitCode does allow a string or an integer, but we prefer just a number
    if (
      exitCode === 0 &&
      contextOptions &&
      typeof contextOptions !== 'function' &&
      contextOptions.error
    ) {
      exitCode = 1;
    }
    // message: do not have all displayed text available so only passing placeholder.
    this._exit(exitCode, 'commander.help', '(outputHelp)');
  }

  /**
   * // Do a little typing to coordinate emit and listener for the help text events.
   * @typedef HelpTextEventContext
   * @type {object}
   * @property {boolean} error
   * @property {Command} command
   * @property {function} write
   */

  /**
   * Add additional text to be displayed with the built-in help.
   *
   * Position is 'before' or 'after' to affect just this command,
   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
   *
   * @param {string} position - before or after built-in help
   * @param {(string | Function)} text - string to add, or a function returning a string
   * @return {Command} `this` command for chaining
   */

  addHelpText(position, text) {
    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];
    if (!allowedValues.includes(position)) {
      throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
    }

    const helpEvent = `${position}Help`;
    this.on(helpEvent, (/** @type {HelpTextEventContext} */ context) => {
      let helpStr;
      if (typeof text === 'function') {
        helpStr = text({ error: context.error, command: context.command });
      } else {
        helpStr = text;
      }
      // Ignore falsy value when nothing to output.
      if (helpStr) {
        context.write(`${helpStr}\n`);
      }
    });
    return this;
  }

  /**
   * Output help information if help flags specified
   *
   * @param {Array} args - array of options to search for help flags
   * @private
   */

  _outputHelpIfRequested(args) {
    const helpOption = this._getHelpOption();
    const helpRequested = helpOption && args.find((arg) => helpOption.is(arg));
    if (helpRequested) {
      this.outputHelp();
      // (Do not have all displayed text available so only passing placeholder.)
      this._exit(0, 'commander.helpDisplayed', '(outputHelp)');
    }
  }
}

/**
 * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
 *
 * @param {string[]} args - array of arguments from node.execArgv
 * @returns {string[]}
 * @private
 */

function incrementNodeInspectorPort(args) {
  // Testing for these options:
  //  --inspect[=[host:]port]
  //  --inspect-brk[=[host:]port]
  //  --inspect-port=[host:]port
  return args.map((arg) => {
    if (!arg.startsWith('--inspect')) {
      return arg;
    }
    let debugOption;
    let debugHost = '127.0.0.1';
    let debugPort = '9229';
    let match;
    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
      // e.g. --inspect
      debugOption = match[1];
    } else if (
      (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null
    ) {
      debugOption = match[1];
      if (/^\d+$/.test(match[3])) {
        // e.g. --inspect=1234
        debugPort = match[3];
      } else {
        // e.g. --inspect=localhost
        debugHost = match[3];
      }
    } else if (
      (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null
    ) {
      // e.g. --inspect=localhost:1234
      debugOption = match[1];
      debugHost = match[3];
      debugPort = match[4];
    }

    if (debugOption && debugPort !== '0') {
      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
    }
    return arg;
  });
}

/**
 * @returns {boolean | undefined}
 * @package
 */
function useColor() {
  // Test for common conventions.
  // NB: the observed behaviour is in combination with how author adds color! For example:
  //   - we do not test NODE_DISABLE_COLORS, but util:styletext does
  //   - we do test NO_COLOR, but Chalk does not
  //
  // References:
  // https://no-color.org
  // https://bixense.com/clicolors/
  // https://github.com/nodejs/node/blob/0a00217a5f67ef4a22384cfc80eb6dd9a917fdc1/lib/internal/tty.js#L109
  // https://github.com/chalk/supports-color/blob/c214314a14bcb174b12b3014b2b0a8de375029ae/index.js#L33
  // (https://force-color.org recent web page from 2023, does not match major javascript implementations)

  if (
    process.env.NO_COLOR ||
    process.env.FORCE_COLOR === '0' ||
    process.env.FORCE_COLOR === 'false'
  )
    return false;
  if (process.env.FORCE_COLOR || process.env.CLICOLOR_FORCE !== undefined)
    return true;
  return undefined;
}

exports.Command = Command;
exports.useColor = useColor; // exporting for tests


/***/ }),

/***/ 453:
/***/ ((__unused_webpack_module, exports) => {

/**
 * CommanderError class
 */
class CommanderError extends Error {
  /**
   * Constructs the CommanderError class
   * @param {number} exitCode suggested exit code which could be used with process.exit
   * @param {string} code an id string representing the error
   * @param {string} message human-readable description of the error
   */
  constructor(exitCode, code, message) {
    super(message);
    // properly capture stack trace in Node.js
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
    this.code = code;
    this.exitCode = exitCode;
    this.nestedError = undefined;
  }
}

/**
 * InvalidArgumentError class
 */
class InvalidArgumentError extends CommanderError {
  /**
   * Constructs the InvalidArgumentError class
   * @param {string} [message] explanation of why argument is invalid
   */
  constructor(message) {
    super(1, 'commander.invalidArgument', message);
    // properly capture stack trace in Node.js
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
  }
}

exports.CommanderError = CommanderError;
exports.InvalidArgumentError = InvalidArgumentError;


/***/ }),

/***/ 420:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

const { humanReadableArgName } = __nccwpck_require__(464);

/**
 * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`
 * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types
 * @typedef { import("./argument.js").Argument } Argument
 * @typedef { import("./command.js").Command } Command
 * @typedef { import("./option.js").Option } Option
 */

// Although this is a class, methods are static in style to allow override using subclass or just functions.
class Help {
  constructor() {
    this.helpWidth = undefined;
    this.minWidthToWrap = 40;
    this.sortSubcommands = false;
    this.sortOptions = false;
    this.showGlobalOptions = false;
  }

  /**
   * prepareContext is called by Commander after applying overrides from `Command.configureHelp()`
   * and just before calling `formatHelp()`.
   *
   * Commander just uses the helpWidth and the rest is provided for optional use by more complex subclasses.
   *
   * @param {{ error?: boolean, helpWidth?: number, outputHasColors?: boolean }} contextOptions
   */
  prepareContext(contextOptions) {
    this.helpWidth = this.helpWidth ?? contextOptions.helpWidth ?? 80;
  }

  /**
   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
   *
   * @param {Command} cmd
   * @returns {Command[]}
   */

  visibleCommands(cmd) {
    const visibleCommands = cmd.commands.filter((cmd) => !cmd._hidden);
    const helpCommand = cmd._getHelpCommand();
    if (helpCommand && !helpCommand._hidden) {
      visibleCommands.push(helpCommand);
    }
    if (this.sortSubcommands) {
      visibleCommands.sort((a, b) => {
        // @ts-ignore: because overloaded return type
        return a.name().localeCompare(b.name());
      });
    }
    return visibleCommands;
  }

  /**
   * Compare options for sort.
   *
   * @param {Option} a
   * @param {Option} b
   * @returns {number}
   */
  compareOptions(a, b) {
    const getSortKey = (option) => {
      // WYSIWYG for order displayed in help. Short used for comparison if present. No special handling for negated.
      return option.short
        ? option.short.replace(/^-/, '')
        : option.long.replace(/^--/, '');
    };
    return getSortKey(a).localeCompare(getSortKey(b));
  }

  /**
   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
   *
   * @param {Command} cmd
   * @returns {Option[]}
   */

  visibleOptions(cmd) {
    const visibleOptions = cmd.options.filter((option) => !option.hidden);
    // Built-in help option.
    const helpOption = cmd._getHelpOption();
    if (helpOption && !helpOption.hidden) {
      // Automatically hide conflicting flags. Bit dubious but a historical behaviour that is convenient for single-command programs.
      const removeShort = helpOption.short && cmd._findOption(helpOption.short);
      const removeLong = helpOption.long && cmd._findOption(helpOption.long);
      if (!removeShort && !removeLong) {
        visibleOptions.push(helpOption); // no changes needed
      } else if (helpOption.long && !removeLong) {
        visibleOptions.push(
          cmd.createOption(helpOption.long, helpOption.description),
        );
      } else if (helpOption.short && !removeShort) {
        visibleOptions.push(
          cmd.createOption(helpOption.short, helpOption.description),
        );
      }
    }
    if (this.sortOptions) {
      visibleOptions.sort(this.compareOptions);
    }
    return visibleOptions;
  }

  /**
   * Get an array of the visible global options. (Not including help.)
   *
   * @param {Command} cmd
   * @returns {Option[]}
   */

  visibleGlobalOptions(cmd) {
    if (!this.showGlobalOptions) return [];

    const globalOptions = [];
    for (
      let ancestorCmd = cmd.parent;
      ancestorCmd;
      ancestorCmd = ancestorCmd.parent
    ) {
      const visibleOptions = ancestorCmd.options.filter(
        (option) => !option.hidden,
      );
      globalOptions.push(...visibleOptions);
    }
    if (this.sortOptions) {
      globalOptions.sort(this.compareOptions);
    }
    return globalOptions;
  }

  /**
   * Get an array of the arguments if any have a description.
   *
   * @param {Command} cmd
   * @returns {Argument[]}
   */

  visibleArguments(cmd) {
    // Side effect! Apply the legacy descriptions before the arguments are displayed.
    if (cmd._argsDescription) {
      cmd.registeredArguments.forEach((argument) => {
        argument.description =
          argument.description || cmd._argsDescription[argument.name()] || '';
      });
    }

    // If there are any arguments with a description then return all the arguments.
    if (cmd.registeredArguments.find((argument) => argument.description)) {
      return cmd.registeredArguments;
    }
    return [];
  }

  /**
   * Get the command term to show in the list of subcommands.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  subcommandTerm(cmd) {
    // Legacy. Ignores custom usage string, and nested commands.
    const args = cmd.registeredArguments
      .map((arg) => humanReadableArgName(arg))
      .join(' ');
    return (
      cmd._name +
      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +
      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option
      (args ? ' ' + args : '')
    );
  }

  /**
   * Get the option term to show in the list of options.
   *
   * @param {Option} option
   * @returns {string}
   */

  optionTerm(option) {
    return option.flags;
  }

  /**
   * Get the argument term to show in the list of arguments.
   *
   * @param {Argument} argument
   * @returns {string}
   */

  argumentTerm(argument) {
    return argument.name();
  }

  /**
   * Get the longest command term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestSubcommandTermLength(cmd, helper) {
    return helper.visibleCommands(cmd).reduce((max, command) => {
      return Math.max(
        max,
        this.displayWidth(
          helper.styleSubcommandTerm(helper.subcommandTerm(command)),
        ),
      );
    }, 0);
  }

  /**
   * Get the longest option term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestOptionTermLength(cmd, helper) {
    return helper.visibleOptions(cmd).reduce((max, option) => {
      return Math.max(
        max,
        this.displayWidth(helper.styleOptionTerm(helper.optionTerm(option))),
      );
    }, 0);
  }

  /**
   * Get the longest global option term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestGlobalOptionTermLength(cmd, helper) {
    return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
      return Math.max(
        max,
        this.displayWidth(helper.styleOptionTerm(helper.optionTerm(option))),
      );
    }, 0);
  }

  /**
   * Get the longest argument term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestArgumentTermLength(cmd, helper) {
    return helper.visibleArguments(cmd).reduce((max, argument) => {
      return Math.max(
        max,
        this.displayWidth(
          helper.styleArgumentTerm(helper.argumentTerm(argument)),
        ),
      );
    }, 0);
  }

  /**
   * Get the command usage to be displayed at the top of the built-in help.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  commandUsage(cmd) {
    // Usage
    let cmdName = cmd._name;
    if (cmd._aliases[0]) {
      cmdName = cmdName + '|' + cmd._aliases[0];
    }
    let ancestorCmdNames = '';
    for (
      let ancestorCmd = cmd.parent;
      ancestorCmd;
      ancestorCmd = ancestorCmd.parent
    ) {
      ancestorCmdNames = ancestorCmd.name() + ' ' + ancestorCmdNames;
    }
    return ancestorCmdNames + cmdName + ' ' + cmd.usage();
  }

  /**
   * Get the description for the command.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  commandDescription(cmd) {
    // @ts-ignore: because overloaded return type
    return cmd.description();
  }

  /**
   * Get the subcommand summary to show in the list of subcommands.
   * (Fallback to description for backwards compatibility.)
   *
   * @param {Command} cmd
   * @returns {string}
   */

  subcommandDescription(cmd) {
    // @ts-ignore: because overloaded return type
    return cmd.summary() || cmd.description();
  }

  /**
   * Get the option description to show in the list of options.
   *
   * @param {Option} option
   * @return {string}
   */

  optionDescription(option) {
    const extraInfo = [];

    if (option.argChoices) {
      extraInfo.push(
        // use stringify to match the display of the default value
        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`,
      );
    }
    if (option.defaultValue !== undefined) {
      // default for boolean and negated more for programmer than end user,
      // but show true/false for boolean option as may be for hand-rolled env or config processing.
      const showDefault =
        option.required ||
        option.optional ||
        (option.isBoolean() && typeof option.defaultValue === 'boolean');
      if (showDefault) {
        extraInfo.push(
          `default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`,
        );
      }
    }
    // preset for boolean and negated are more for programmer than end user
    if (option.presetArg !== undefined && option.optional) {
      extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
    }
    if (option.envVar !== undefined) {
      extraInfo.push(`env: ${option.envVar}`);
    }
    if (extraInfo.length > 0) {
      const extraDescription = `(${extraInfo.join(', ')})`;
      if (option.description) {
        return `${option.description} ${extraDescription}`;
      }
      return extraDescription;
    }

    return option.description;
  }

  /**
   * Get the argument description to show in the list of arguments.
   *
   * @param {Argument} argument
   * @return {string}
   */

  argumentDescription(argument) {
    const extraInfo = [];
    if (argument.argChoices) {
      extraInfo.push(
        // use stringify to match the display of the default value
        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`,
      );
    }
    if (argument.defaultValue !== undefined) {
      extraInfo.push(
        `default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`,
      );
    }
    if (extraInfo.length > 0) {
      const extraDescription = `(${extraInfo.join(', ')})`;
      if (argument.description) {
        return `${argument.description} ${extraDescription}`;
      }
      return extraDescription;
    }
    return argument.description;
  }

  /**
   * Format a list of items, given a heading and an array of formatted items.
   *
   * @param {string} heading
   * @param {string[]} items
   * @param {Help} helper
   * @returns string[]
   */
  formatItemList(heading, items, helper) {
    if (items.length === 0) return [];

    return [helper.styleTitle(heading), ...items, ''];
  }

  /**
   * Group items by their help group heading.
   *
   * @param {Command[] | Option[]} unsortedItems
   * @param {Command[] | Option[]} visibleItems
   * @param {Function} getGroup
   * @returns {Map<string, Command[] | Option[]>}
   */
  groupItems(unsortedItems, visibleItems, getGroup) {
    const result = new Map();
    // Add groups in order of appearance in unsortedItems.
    unsortedItems.forEach((item) => {
      const group = getGroup(item);
      if (!result.has(group)) result.set(group, []);
    });
    // Add items in order of appearance in visibleItems.
    visibleItems.forEach((item) => {
      const group = getGroup(item);
      if (!result.has(group)) {
        result.set(group, []);
      }
      result.get(group).push(item);
    });
    return result;
  }

  /**
   * Generate the built-in help text.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {string}
   */

  formatHelp(cmd, helper) {
    const termWidth = helper.padWidth(cmd, helper);
    const helpWidth = helper.helpWidth ?? 80; // in case prepareContext() was not called

    function callFormatItem(term, description) {
      return helper.formatItem(term, termWidth, description, helper);
    }

    // Usage
    let output = [
      `${helper.styleTitle('Usage:')} ${helper.styleUsage(helper.commandUsage(cmd))}`,
      '',
    ];

    // Description
    const commandDescription = helper.commandDescription(cmd);
    if (commandDescription.length > 0) {
      output = output.concat([
        helper.boxWrap(
          helper.styleCommandDescription(commandDescription),
          helpWidth,
        ),
        '',
      ]);
    }

    // Arguments
    const argumentList = helper.visibleArguments(cmd).map((argument) => {
      return callFormatItem(
        helper.styleArgumentTerm(helper.argumentTerm(argument)),
        helper.styleArgumentDescription(helper.argumentDescription(argument)),
      );
    });
    output = output.concat(
      this.formatItemList('Arguments:', argumentList, helper),
    );

    // Options
    const optionGroups = this.groupItems(
      cmd.options,
      helper.visibleOptions(cmd),
      (option) => option.helpGroupHeading ?? 'Options:',
    );
    optionGroups.forEach((options, group) => {
      const optionList = options.map((option) => {
        return callFormatItem(
          helper.styleOptionTerm(helper.optionTerm(option)),
          helper.styleOptionDescription(helper.optionDescription(option)),
        );
      });
      output = output.concat(this.formatItemList(group, optionList, helper));
    });

    if (helper.showGlobalOptions) {
      const globalOptionList = helper
        .visibleGlobalOptions(cmd)
        .map((option) => {
          return callFormatItem(
            helper.styleOptionTerm(helper.optionTerm(option)),
            helper.styleOptionDescription(helper.optionDescription(option)),
          );
        });
      output = output.concat(
        this.formatItemList('Global Options:', globalOptionList, helper),
      );
    }

    // Commands
    const commandGroups = this.groupItems(
      cmd.commands,
      helper.visibleCommands(cmd),
      (sub) => sub.helpGroup() || 'Commands:',
    );
    commandGroups.forEach((commands, group) => {
      const commandList = commands.map((sub) => {
        return callFormatItem(
          helper.styleSubcommandTerm(helper.subcommandTerm(sub)),
          helper.styleSubcommandDescription(helper.subcommandDescription(sub)),
        );
      });
      output = output.concat(this.formatItemList(group, commandList, helper));
    });

    return output.join('\n');
  }

  /**
   * Return display width of string, ignoring ANSI escape sequences. Used in padding and wrapping calculations.
   *
   * @param {string} str
   * @returns {number}
   */
  displayWidth(str) {
    return stripColor(str).length;
  }

  /**
   * Style the title for displaying in the help. Called with 'Usage:', 'Options:', etc.
   *
   * @param {string} str
   * @returns {string}
   */
  styleTitle(str) {
    return str;
  }

  styleUsage(str) {
    // Usage has lots of parts the user might like to color separately! Assume default usage string which is formed like:
    //    command subcommand [options] [command] <foo> [bar]
    return str
      .split(' ')
      .map((word) => {
        if (word === '[options]') return this.styleOptionText(word);
        if (word === '[command]') return this.styleSubcommandText(word);
        if (word[0] === '[' || word[0] === '<')
          return this.styleArgumentText(word);
        return this.styleCommandText(word); // Restrict to initial words?
      })
      .join(' ');
  }
  styleCommandDescription(str) {
    return this.styleDescriptionText(str);
  }
  styleOptionDescription(str) {
    return this.styleDescriptionText(str);
  }
  styleSubcommandDescription(str) {
    return this.styleDescriptionText(str);
  }
  styleArgumentDescription(str) {
    return this.styleDescriptionText(str);
  }
  styleDescriptionText(str) {
    return str;
  }
  styleOptionTerm(str) {
    return this.styleOptionText(str);
  }
  styleSubcommandTerm(str) {
    // This is very like usage with lots of parts! Assume default string which is formed like:
    //    subcommand [options] <foo> [bar]
    return str
      .split(' ')
      .map((word) => {
        if (word === '[options]') return this.styleOptionText(word);
        if (word[0] === '[' || word[0] === '<')
          return this.styleArgumentText(word);
        return this.styleSubcommandText(word); // Restrict to initial words?
      })
      .join(' ');
  }
  styleArgumentTerm(str) {
    return this.styleArgumentText(str);
  }
  styleOptionText(str) {
    return str;
  }
  styleArgumentText(str) {
    return str;
  }
  styleSubcommandText(str) {
    return str;
  }
  styleCommandText(str) {
    return str;
  }

  /**
   * Calculate the pad width from the maximum term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  padWidth(cmd, helper) {
    return Math.max(
      helper.longestOptionTermLength(cmd, helper),
      helper.longestGlobalOptionTermLength(cmd, helper),
      helper.longestSubcommandTermLength(cmd, helper),
      helper.longestArgumentTermLength(cmd, helper),
    );
  }

  /**
   * Detect manually wrapped and indented strings by checking for line break followed by whitespace.
   *
   * @param {string} str
   * @returns {boolean}
   */
  preformatted(str) {
    return /\n[^\S\r\n]/.test(str);
  }

  /**
   * Format the "item", which consists of a term and description. Pad the term and wrap the description, indenting the following lines.
   *
   * So "TTT", 5, "DDD DDDD DD DDD" might be formatted for this.helpWidth=17 like so:
   *   TTT  DDD DDDD
   *        DD DDD
   *
   * @param {string} term
   * @param {number} termWidth
   * @param {string} description
   * @param {Help} helper
   * @returns {string}
   */
  formatItem(term, termWidth, description, helper) {
    const itemIndent = 2;
    const itemIndentStr = ' '.repeat(itemIndent);
    if (!description) return itemIndentStr + term;

    // Pad the term out to a consistent width, so descriptions are aligned.
    const paddedTerm = term.padEnd(
      termWidth + term.length - helper.displayWidth(term),
    );

    // Format the description.
    const spacerWidth = 2; // between term and description
    const helpWidth = this.helpWidth ?? 80; // in case prepareContext() was not called
    const remainingWidth = helpWidth - termWidth - spacerWidth - itemIndent;
    let formattedDescription;
    if (
      remainingWidth < this.minWidthToWrap ||
      helper.preformatted(description)
    ) {
      formattedDescription = description;
    } else {
      const wrappedDescription = helper.boxWrap(description, remainingWidth);
      formattedDescription = wrappedDescription.replace(
        /\n/g,
        '\n' + ' '.repeat(termWidth + spacerWidth),
      );
    }

    // Construct and overall indent.
    return (
      itemIndentStr +
      paddedTerm +
      ' '.repeat(spacerWidth) +
      formattedDescription.replace(/\n/g, `\n${itemIndentStr}`)
    );
  }

  /**
   * Wrap a string at whitespace, preserving existing line breaks.
   * Wrapping is skipped if the width is less than `minWidthToWrap`.
   *
   * @param {string} str
   * @param {number} width
   * @returns {string}
   */
  boxWrap(str, width) {
    if (width < this.minWidthToWrap) return str;

    const rawLines = str.split(/\r\n|\n/);
    // split up text by whitespace
    const chunkPattern = /[\s]*[^\s]+/g;
    const wrappedLines = [];
    rawLines.forEach((line) => {
      const chunks = line.match(chunkPattern);
      if (chunks === null) {
        wrappedLines.push('');
        return;
      }

      let sumChunks = [chunks.shift()];
      let sumWidth = this.displayWidth(sumChunks[0]);
      chunks.forEach((chunk) => {
        const visibleWidth = this.displayWidth(chunk);
        // Accumulate chunks while they fit into width.
        if (sumWidth + visibleWidth <= width) {
          sumChunks.push(chunk);
          sumWidth += visibleWidth;
          return;
        }
        wrappedLines.push(sumChunks.join(''));

        const nextChunk = chunk.trimStart(); // trim space at line break
        sumChunks = [nextChunk];
        sumWidth = this.displayWidth(nextChunk);
      });
      wrappedLines.push(sumChunks.join(''));
    });

    return wrappedLines.join('\n');
  }
}

/**
 * Strip style ANSI escape sequences from the string. In particular, SGR (Select Graphic Rendition) codes.
 *
 * @param {string} str
 * @returns {string}
 * @package
 */

function stripColor(str) {
  // eslint-disable-next-line no-control-regex
  const sgrPattern = /\x1b\[\d*(;\d*)*m/g;
  return str.replace(sgrPattern, '');
}

exports.Help = Help;
exports.stripColor = stripColor;


/***/ }),

/***/ 246:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

const { InvalidArgumentError } = __nccwpck_require__(453);

class Option {
  /**
   * Initialize a new `Option` with the given `flags` and `description`.
   *
   * @param {string} flags
   * @param {string} [description]
   */

  constructor(flags, description) {
    this.flags = flags;
    this.description = description || '';

    this.required = flags.includes('<'); // A value must be supplied when the option is specified.
    this.optional = flags.includes('['); // A value is optional when the option is specified.
    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument
    this.variadic = /\w\.\.\.[>\]]$/.test(flags); // The option can take multiple values.
    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.
    const optionFlags = splitOptionFlags(flags);
    this.short = optionFlags.shortFlag; // May be a short flag, undefined, or even a long flag (if option has two long flags).
    this.long = optionFlags.longFlag;
    this.negate = false;
    if (this.long) {
      this.negate = this.long.startsWith('--no-');
    }
    this.defaultValue = undefined;
    this.defaultValueDescription = undefined;
    this.presetArg = undefined;
    this.envVar = undefined;
    this.parseArg = undefined;
    this.hidden = false;
    this.argChoices = undefined;
    this.conflictsWith = [];
    this.implied = undefined;
    this.helpGroupHeading = undefined; // soft initialised when option added to command
  }

  /**
   * Set the default value, and optionally supply the description to be displayed in the help.
   *
   * @param {*} value
   * @param {string} [description]
   * @return {Option}
   */

  default(value, description) {
    this.defaultValue = value;
    this.defaultValueDescription = description;
    return this;
  }

  /**
   * Preset to use when option used without option-argument, especially optional but also boolean and negated.
   * The custom processing (parseArg) is called.
   *
   * @example
   * new Option('--color').default('GREYSCALE').preset('RGB');
   * new Option('--donate [amount]').preset('20').argParser(parseFloat);
   *
   * @param {*} arg
   * @return {Option}
   */

  preset(arg) {
    this.presetArg = arg;
    return this;
  }

  /**
   * Add option name(s) that conflict with this option.
   * An error will be displayed if conflicting options are found during parsing.
   *
   * @example
   * new Option('--rgb').conflicts('cmyk');
   * new Option('--js').conflicts(['ts', 'jsx']);
   *
   * @param {(string | string[])} names
   * @return {Option}
   */

  conflicts(names) {
    this.conflictsWith = this.conflictsWith.concat(names);
    return this;
  }

  /**
   * Specify implied option values for when this option is set and the implied options are not.
   *
   * The custom processing (parseArg) is not called on the implied values.
   *
   * @example
   * program
   *   .addOption(new Option('--log', 'write logging information to file'))
   *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
   *
   * @param {object} impliedOptionValues
   * @return {Option}
   */
  implies(impliedOptionValues) {
    let newImplied = impliedOptionValues;
    if (typeof impliedOptionValues === 'string') {
      // string is not documented, but easy mistake and we can do what user probably intended.
      newImplied = { [impliedOptionValues]: true };
    }
    this.implied = Object.assign(this.implied || {}, newImplied);
    return this;
  }

  /**
   * Set environment variable to check for option value.
   *
   * An environment variable is only used if when processed the current option value is
   * undefined, or the source of the current value is 'default' or 'config' or 'env'.
   *
   * @param {string} name
   * @return {Option}
   */

  env(name) {
    this.envVar = name;
    return this;
  }

  /**
   * Set the custom handler for processing CLI option arguments into option values.
   *
   * @param {Function} [fn]
   * @return {Option}
   */

  argParser(fn) {
    this.parseArg = fn;
    return this;
  }

  /**
   * Whether the option is mandatory and must have a value after parsing.
   *
   * @param {boolean} [mandatory=true]
   * @return {Option}
   */

  makeOptionMandatory(mandatory = true) {
    this.mandatory = !!mandatory;
    return this;
  }

  /**
   * Hide option in help.
   *
   * @param {boolean} [hide=true]
   * @return {Option}
   */

  hideHelp(hide = true) {
    this.hidden = !!hide;
    return this;
  }

  /**
   * @package
   */

  _collectValue(value, previous) {
    if (previous === this.defaultValue || !Array.isArray(previous)) {
      return [value];
    }

    previous.push(value);
    return previous;
  }

  /**
   * Only allow option value to be one of choices.
   *
   * @param {string[]} values
   * @return {Option}
   */

  choices(values) {
    this.argChoices = values.slice();
    this.parseArg = (arg, previous) => {
      if (!this.argChoices.includes(arg)) {
        throw new InvalidArgumentError(
          `Allowed choices are ${this.argChoices.join(', ')}.`,
        );
      }
      if (this.variadic) {
        return this._collectValue(arg, previous);
      }
      return arg;
    };
    return this;
  }

  /**
   * Return option name.
   *
   * @return {string}
   */

  name() {
    if (this.long) {
      return this.long.replace(/^--/, '');
    }
    return this.short.replace(/^-/, '');
  }

  /**
   * Return option name, in a camelcase format that can be used
   * as an object attribute key.
   *
   * @return {string}
   */

  attributeName() {
    if (this.negate) {
      return camelcase(this.name().replace(/^no-/, ''));
    }
    return camelcase(this.name());
  }

  /**
   * Set the help group heading.
   *
   * @param {string} heading
   * @return {Option}
   */
  helpGroup(heading) {
    this.helpGroupHeading = heading;
    return this;
  }

  /**
   * Check if `arg` matches the short or long flag.
   *
   * @param {string} arg
   * @return {boolean}
   * @package
   */

  is(arg) {
    return this.short === arg || this.long === arg;
  }

  /**
   * Return whether a boolean option.
   *
   * Options are one of boolean, negated, required argument, or optional argument.
   *
   * @return {boolean}
   * @package
   */

  isBoolean() {
    return !this.required && !this.optional && !this.negate;
  }
}

/**
 * This class is to make it easier to work with dual options, without changing the existing
 * implementation. We support separate dual options for separate positive and negative options,
 * like `--build` and `--no-build`, which share a single option value. This works nicely for some
 * use cases, but is tricky for others where we want separate behaviours despite
 * the single shared option value.
 */
class DualOptions {
  /**
   * @param {Option[]} options
   */
  constructor(options) {
    this.positiveOptions = new Map();
    this.negativeOptions = new Map();
    this.dualOptions = new Set();
    options.forEach((option) => {
      if (option.negate) {
        this.negativeOptions.set(option.attributeName(), option);
      } else {
        this.positiveOptions.set(option.attributeName(), option);
      }
    });
    this.negativeOptions.forEach((value, key) => {
      if (this.positiveOptions.has(key)) {
        this.dualOptions.add(key);
      }
    });
  }

  /**
   * Did the value come from the option, and not from possible matching dual option?
   *
   * @param {*} value
   * @param {Option} option
   * @returns {boolean}
   */
  valueFromOption(value, option) {
    const optionKey = option.attributeName();
    if (!this.dualOptions.has(optionKey)) return true;

    // Use the value to deduce if (probably) came from the option.
    const preset = this.negativeOptions.get(optionKey).presetArg;
    const negativeValue = preset !== undefined ? preset : false;
    return option.negate === (negativeValue === value);
  }
}

/**
 * Convert string from kebab-case to camelCase.
 *
 * @param {string} str
 * @return {string}
 * @private
 */

function camelcase(str) {
  return str.split('-').reduce((str, word) => {
    return str + word[0].toUpperCase() + word.slice(1);
  });
}

/**
 * Split the short and long flag out of something like '-m,--mixed <value>'
 *
 * @private
 */

function splitOptionFlags(flags) {
  let shortFlag;
  let longFlag;
  // short flag, single dash and single character
  const shortFlagExp = /^-[^-]$/;
  // long flag, double dash and at least one character
  const longFlagExp = /^--[^-]/;

  const flagParts = flags.split(/[ |,]+/).concat('guard');
  // Normal is short and/or long.
  if (shortFlagExp.test(flagParts[0])) shortFlag = flagParts.shift();
  if (longFlagExp.test(flagParts[0])) longFlag = flagParts.shift();
  // Long then short. Rarely used but fine.
  if (!shortFlag && shortFlagExp.test(flagParts[0]))
    shortFlag = flagParts.shift();
  // Allow two long flags, like '--ws, --workspace'
  // This is the supported way to have a shortish option flag.
  if (!shortFlag && longFlagExp.test(flagParts[0])) {
    shortFlag = longFlag;
    longFlag = flagParts.shift();
  }

  // Check for unprocessed flag. Fail noisily rather than silently ignore.
  if (flagParts[0].startsWith('-')) {
    const unsupportedFlag = flagParts[0];
    const baseError = `option creation failed due to '${unsupportedFlag}' in option flags '${flags}'`;
    if (/^-[^-][^-]/.test(unsupportedFlag))
      throw new Error(
        `${baseError}
- a short flag is a single dash and a single character
  - either use a single dash and a single character (for a short flag)
  - or use a double dash for a long option (and can have two, like '--ws, --workspace')`,
      );
    if (shortFlagExp.test(unsupportedFlag))
      throw new Error(`${baseError}
- too many short flags`);
    if (longFlagExp.test(unsupportedFlag))
      throw new Error(`${baseError}
- too many long flags`);

    throw new Error(`${baseError}
- unrecognised flag format`);
  }
  if (shortFlag === undefined && longFlag === undefined)
    throw new Error(
      `option creation failed due to no flags found in '${flags}'.`,
    );

  return { shortFlag, longFlag };
}

exports.Option = Option;
exports.DualOptions = DualOptions;


/***/ }),

/***/ 504:
/***/ ((__unused_webpack_module, exports) => {

const maxDistance = 3;

function editDistance(a, b) {
  // https://en.wikipedia.org/wiki/DamerauLevenshtein_distance
  // Calculating optimal string alignment distance, no substring is edited more than once.
  // (Simple implementation.)

  // Quick early exit, return worst case.
  if (Math.abs(a.length - b.length) > maxDistance)
    return Math.max(a.length, b.length);

  // distance between prefix substrings of a and b
  const d = [];

  // pure deletions turn a into empty string
  for (let i = 0; i <= a.length; i++) {
    d[i] = [i];
  }
  // pure insertions turn empty string into b
  for (let j = 0; j <= b.length; j++) {
    d[0][j] = j;
  }

  // fill matrix
  for (let j = 1; j <= b.length; j++) {
    for (let i = 1; i <= a.length; i++) {
      let cost = 1;
      if (a[i - 1] === b[j - 1]) {
        cost = 0;
      } else {
        cost = 1;
      }
      d[i][j] = Math.min(
        d[i - 1][j] + 1, // deletion
        d[i][j - 1] + 1, // insertion
        d[i - 1][j - 1] + cost, // substitution
      );
      // transposition
      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
      }
    }
  }

  return d[a.length][b.length];
}

/**
 * Find close matches, restricted to same number of edits.
 *
 * @param {string} word
 * @param {string[]} candidates
 * @returns {string}
 */

function suggestSimilar(word, candidates) {
  if (!candidates || candidates.length === 0) return '';
  // remove possible duplicates
  candidates = Array.from(new Set(candidates));

  const searchingOptions = word.startsWith('--');
  if (searchingOptions) {
    word = word.slice(2);
    candidates = candidates.map((candidate) => candidate.slice(2));
  }

  let similar = [];
  let bestDistance = maxDistance;
  const minSimilarity = 0.4;
  candidates.forEach((candidate) => {
    if (candidate.length <= 1) return; // no one character guesses

    const distance = editDistance(word, candidate);
    const length = Math.max(word.length, candidate.length);
    const similarity = (length - distance) / length;
    if (similarity > minSimilarity) {
      if (distance < bestDistance) {
        // better edit distance, throw away previous worse matches
        bestDistance = distance;
        similar = [candidate];
      } else if (distance === bestDistance) {
        similar.push(candidate);
      }
    }
  });

  similar.sort((a, b) => a.localeCompare(b));
  if (searchingOptions) {
    similar = similar.map((candidate) => `--${candidate}`);
  }

  if (similar.length > 1) {
    return `\n(Did you mean one of ${similar.join(', ')}?)`;
  }
  if (similar.length === 1) {
    return `\n(Did you mean ${similar[0]}?)`;
  }
  return '';
}

exports.suggestSimilar = suggestSimilar;


/***/ }),

/***/ 892:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nccwpck_require__) => {

"use strict";
// ESM COMPAT FLAG
__nccwpck_require__.r(__webpack_exports__);

// EXPORTS
__nccwpck_require__.d(__webpack_exports__, {
  BaseGenerator: () => (/* reexport */ BaseGenerator),
  GraphGenerator: () => (/* reexport */ GraphGenerator),
  TypeScriptGenerator: () => (/* reexport */ TypeScriptGenerator),
  _multilineCommentParser: () => (/* reexport */ _multilineCommentParser),
  agencyNode: () => (/* reexport */ agencyNode),
  agencyParser: () => (/* reexport */ agencyParser),
  generateGraph: () => (/* reexport */ generateGraph),
  generateTypeScript: () => (/* reexport */ generateTypeScript),
  multilineCommentParser: () => (/* reexport */ multilineCommentParser),
  parseAgency: () => (/* reexport */ parseAgency)
});

;// CONCATENATED MODULE: ./node_modules/.pnpm/tarsec@0.1.1/node_modules/tarsec/dist/utils.js
function utils_escape(str) {
    return JSON.stringify(str);
}
function merge(a, b) {
    if (Array.isArray(a) && Array.isArray(b)) {
        return [...a, ...b];
    }
    else if (Array.isArray(a)) {
        return [...a, b];
    }
    else if (Array.isArray(b)) {
        return [a, ...b];
    }
    else {
        return [a, b];
    }
}
function mergeCaptures(a, b) {
    const result = {};
    Object.keys(a).forEach((key) => {
        result[key] = a[key];
    });
    Object.keys(b).forEach((key) => {
        if (result[key]) {
            result[key] = merge(result[key], b[key]);
        }
        else {
            result[key] = b[key];
        }
    });
    return result;
}
function findAncestorWithNextParser(node, count = 0) {
    if (node === null)
        return [null, count];
    if (!node.closed) {
        return [node, count];
    }
    if (node.parent) {
        return findAncestorWithNextParser(node.parent, count + 1);
    }
    return [null, count];
}
function popMany(arr, count) {
    for (let i = 0; i < count; i++) {
        arr.pop();
    }
}
function utils_round(num, places = 2) {
    return Math.round(num * 10 ** places) / 10 ** places;
}
function shorten(str, length = 250) {
    if (str.length > length) {
        return str.substring(0, length) + "...";
    }
    return str;
}

;// CONCATENATED MODULE: external "process"
const external_process_namespaceObject = require("process");
;// CONCATENATED MODULE: ./node_modules/.pnpm/tarsec@0.1.1/node_modules/tarsec/dist/trace.js


const isNode = typeof external_process_namespaceObject !== "undefined" &&
    external_process_namespaceObject.versions != null &&
    external_process_namespaceObject.versions.node != null;
const STEP = 2;
let level = 0;
let counts = {};
let times = {};
let debugFlag = isNode ? !!external_process_namespaceObject.env.DEBUG : false;
let stepCount = 0;
let stepLimit = -1;
let debugMessages = [];
/**
 * This function is used internally by the `trace` function to create the string for each step.
 * @param name - debug name for parser
 * @param result - parser result
 * @returns - A formatted string that describes the parser's result
*/
function resultToString(name, result) {
    if (result.success) {
        return ` ${name} -- match: ${utils_escape(result.result)}, rest: ${utils_escape(result.rest)}`;
    }
    return ` ${name} -- message: ${utils_escape(result.message)}, rest: ${utils_escape(result.rest)}`;
}
function trace_trace(name, parser) {
    if (stepLimit > 0 && stepCount > stepLimit) {
        throw new Error(`parser step limit of ${stepLimit} exceeded, parser may be in an infinite loop`);
    }
    return (input) => {
        if (debugFlag) {
            console.log(" ".repeat(level) + ` ${name} -- input: ${shorten(utils_escape(input))}`);
            let result;
            const time = parserTime(() => {
                level += STEP;
                result = parser(input);
                level -= STEP;
            });
            counts[name] = counts[name] ? counts[name] + 1 : 1;
            stepCount += 1;
            if (time) {
                times[name] = times[name] ? times[name] + time : time;
            }
            console.log(" ".repeat(level) + resultToString(name, result));
            if (result.success && result.captures) {
                console.log(" ".repeat(level) +
                    ` ${name} -- captures: ${JSON.stringify(result.captures)}`);
            }
            return result;
        }
        else {
            return parser(input);
        }
    };
}
function debug(parser, message) {
    return (input) => {
        const result = parser(input);
        if (result.success) {
            return result;
        }
        else {
            debugMessages.push(`${message} -- ${resultToString("", result)}`);
            return result;
        }
    };
}
function getDebugMessages() {
    return debugMessages;
}
function getDebugMessage() {
    return debugMessages[debugMessages.length - 1];
}
/**
 * Utility timing function. Given a callback, it times the callback
 * and returns its runtime in milliseconds. It uses `performance.now()` to do this.
 * If `performance.now()` is not available, it returns null.
 *
 * @param callback - callback to time
 * @returns - time in milliseconds
 */
function parserTime(callback) {
    if (performance && performance.now) {
        const start = performance.now();
        callback();
        const end = performance.now();
        return end - start;
    }
    else {
        console.error("performance.now not available");
        callback();
        return null;
    }
}
/**
 * Wrapper for parser time. Instead of returning the time in milliseconds,
 * it console.logs it, in a nicely formatted string.
 * @param name - debug name for timing
 * @param callback - callback to time
 */
function printTime(name, callback) {
    const time = parserTime(callback);
    if (time) {
        console.log(` ${name} -- time: ${round(time)}ms`);
    }
}
/**
 * This is the recommended way to run a parser in debug mode.
 * Takes a callback and turns debug mode on just for the callback.
 * This enables `trace` to capture all sorts of information
 * about any executed parsers and print them to console.log.
 * `trace` tracks counts and times but they don't actually get reset to zero
 * unless you use this function to wrap your code.
 *
 * @param name - debug name
 * @param callback - callback to run in debug mode
 */
function parserDebug(name, callback) {
    debugFlag = true;
    stepCount = 0;
    counts = {};
    times = {};
    printTime(name, callback);
    debugFlag = false;
    console.log("\n");
    console.log(` ${name} -- counts:`);
    const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
    for (const [name, count] of sorted) {
        console.log(`  ${name}: ${count}`);
    }
    console.log("\n");
    console.log(` ${name} -- times:`);
    const sortedTimes = Object.entries(times).sort((a, b) => b[1] - a[1]);
    for (const [name, time] of sortedTimes) {
        console.log(`  ${name}: ${round(time)}ms`);
    }
    console.log("\n");
    console.log(` ${name} -- step count: ${stepCount}`);
    console.log("\n\n");
    stepCount = 0;
    counts = {};
    times = {};
}
/**
 * Utility function to limit the number of steps a parser can take.
 * This is useful for avoiding infinite loops in your parser.
 * @param limit - number of steps to limit the parser to
 * @param callback - callback to run
 */
function limitSteps(limit, callback) {
    stepLimit = limit;
    callback();
    stepLimit = -1;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/tarsec@0.1.1/node_modules/tarsec/dist/types.js
function isCaptureResult(result) {
    return "captures" in result;
}
/**
 * This typed function is helpful in filtering out the successes
 * from an array of results while preserving type information. For example:
 *
 * ```
 * // type is ParserSuccess[]
 * results.filter(isSuccess);
 *
 * // type is ParserResult[]
 * results.filter(r => r.success);
 * ```
 * @param result - a parser result
 * @returns - true if the result is a success, otherwise false
 */
function types_isSuccess(result) {
    return result.success;
}
/** Convenience function to return a ParserSuccess */
function types_success(result, rest) {
    return { success: true, result, rest };
}
/** Convenience function to return a CaptureParserSuccess */
function captureSuccess(result, rest, captures) {
    return { success: true, result, rest, captures };
}
/** Convenience function to return a ParserFailure */
function types_failure(message, rest) {
    return { success: false, message, rest };
}
/** Convenience function to create a ParserNode. */
function createNode(parent, parser) {
    return {
        parent,
        parser,
        child: null,
        closed: false,
    };
}
/** Convenience function where, given an array of parsers, it creates a tree we can use for backtracking.
 * This tree is what `seq` use. It's used to keep track of the parsers we've tried so far,
 * so we can backtrack if we need to.
 */
function createTree(parsers) {
    if (parsers.length === 0) {
        return null;
    }
    const rootNode = createNode(null, parsers[0]);
    let currentNode = rootNode;
    for (let i = 1; i < parsers.length; i++) {
        currentNode.child = createNode(currentNode, parsers[i]);
        currentNode = currentNode.child;
    }
    return rootNode;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/tarsec@0.1.1/node_modules/tarsec/dist/parsers/within.js


/**
 * `within` is a funny combinator. It finds zero or more instances of `parser` within the input.
 * It always succeeds and returns an array of results, each one being a matched or unmatched string.
 * You could think of "within" as a glorified search. For example, you can use it to
 * look for quoted text or multiline comments within an input.
 *
 * Example:
 *
 * ```ts
 *   const multilineComments = seq(
 *   [str("/*"), manyWithJoin(noneOf(`*\/`)), str("*\/")],
 *   (results: string[]) => results.join("")
 * );
 *   const parser = within(multilineComments);
 *   const input = `code before /* this is a comment *\/ code after /* another comment *\/ end`;
 *
 *   const result = parser(input);
 *   console.log(JSON.stringify(result, null, 2));
 * ```
 *
 * Result:
 *
 * ```json
 * {
 * "success": true,
 * "result": [
 *   {
 *     "type": "unmatched",
 *     "value": "code before "
 *   },
 *   {
 *     "type": "matched",
 *     "value": "/* this is a comment *\/"
 *   },
 *   {
 *     "type": "unmatched",
 *     "value": " code after "
 *   },
 *   {
 *     "type": "matched",
 *     "value": "/* another comment *\/"
 *   },
 *   {
 *     "type": "unmatched",
 *     "value": " end"
 *   }
 * ],
 * "rest": ""
 * }
 * ```
 *
 * This parser is somewhat expensive, as it will go down the input string one character
 * at a time, applying the given parser each time.
 *
 * @param parser - parser to find within the input
 * @returns - an array of matched and unmatched strings
 */
function within_within(parser) {
    return trace_trace("within", (input) => {
        let start = 0;
        let current = 0;
        const results = [];
        while (current < input.length) {
            const parsed = parser(input.slice(current));
            if (parsed.success) {
                const unmatchedValue = input.slice(start, current);
                if (unmatchedValue.length > 0) {
                    results.push({
                        type: "unmatched",
                        value: unmatchedValue,
                    });
                }
                results.push({
                    type: "matched",
                    value: parsed.result,
                });
                current = input.length - parsed.rest.length;
                start = current;
            }
            else {
                current += 1;
            }
        }
        if (start < current) {
            results.push({
                type: "unmatched",
                value: input.slice(start, current),
            });
        }
        return types_success(results, "");
    });
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/tarsec@0.1.1/node_modules/tarsec/dist/combinators.js




/**
 * Takes a parser and runs it zero or more times, returning the results as an array.
 * If the parser is a capture parser, it returns the captures as an array in this form:
 *
 * ```ts
 * { captures: <array of captures> }
 * ```
 *
 * @param parser - parser to run
 * @returns - parser that runs the given parser zero to many times,
 * and returns the result as an array
 */
function many(parser) {
    const _parser = (input) => {
        let results = [];
        let captures = [];
        let rest = input;
        while (true) {
            let parsed = parser(rest);
            if (!parsed.success) {
                if (Object.keys(captures).length) {
                    return captureSuccess(results, rest, { captures });
                }
                else {
                    return types_success(results, rest);
                }
            }
            results.push(parsed.result);
            if (isCaptureResult(parsed)) {
                captures.push(parsed.captures);
            }
            rest = parsed.rest;
            // don't loop infinitely on empty strings
            if (rest === "") {
                if (Object.keys(captures).length) {
                    return captureSuccess(results, rest, { captures });
                }
                else {
                    return types_success(results, rest);
                }
            }
        }
    };
    return trace_trace("many", _parser);
}
/**
 * Same as `many`, but fails if the parser doesn't match at least once.
 *
 * @param parser - parser to run
 * @returns a parser that runs the given parser one to many times,
 */
function many1(parser) {
    return trace_trace(`many1`, (input) => {
        let result = many(parser)(input);
        // this logic doesn't work with optional and not
        if (result.rest !== input) {
            return result;
        }
        return {
            success: false,
            rest: input,
            message: "expected at least one match",
        };
    });
}
/**
 * Takes a parser, runs it, and returns the number of times it succeeded.
 * @param parser - parser to run
 * @returns - the number of times the parser succeeded.
 */
function count(parser) {
    return trace_trace("count", (input) => {
        const result = many(parser)(input);
        if (result.success) {
            if (result.result.length === 0) {
                return types_failure("expected at least one match", input);
            }
            return types_success(result.result.length, result.rest);
        }
        return result;
    });
}
/**
 * Takes a parser, runs it n times, and returns the results as an array.
 * If it cannot run the parser n times, it fails without consuming input.
 * @param num - number of times to run the parser
 * @param parser - parser to run
 * @returns - parser that runs the given parser `num` times and returns an array of the results
 */
function exactly(num, parser) {
    return trace("exactly", (input) => {
        let results = [];
        let rest = input;
        for (let i = 0; i < num; i++) {
            let parsed = parser(rest);
            if (!parsed.success) {
                return failure(`expected ${num} matches, got ${i}`, input);
            }
            results.push(parsed.result);
            rest = parsed.rest;
        }
        return success(results, rest);
    });
}
/**
 * Same as `many`, but joins the results into a single string.
 *
 * @param parser - parser to run. The parser must return a string as its result.
 * @returns - parser that runs the given parser zero to many times,
 * and returns the result as a single string
 */
function manyWithJoin(parser) {
    return trace_trace("manyWithJoin", (input) => {
        const result = many(parser)(input);
        if (result.success) {
            return Object.assign(Object.assign({}, result), { result: result.result.join("") });
        }
        return result;
    });
}
/**
 * Same as `many1`, but joins the results into a single string.
 *
 * @param parser - parser to run. The parser must return a string as its result.
 * @returns - parser that runs the given parser one to many times,
 * and returns the result as a single string
 */
function many1WithJoin(parser) {
    return trace_trace("many1WithJoin", (input) => {
        const result = many1(parser)(input);
        if (result.success) {
            return Object.assign(Object.assign({}, result), { result: result.result.join("") });
        }
        return result;
    });
}
/**
 * `or` takes an array of parsers and runs them sequentially.
 * It returns the results of the first parser that succeeds.
 * You can use `capture` in an `or`:
 *
 * ```ts
 * const parser = or(capture(digit, "num"), capture(word, "name"));
 * ```
 *
 * `or` supports backtracking by returning a `nextParser`:
 *
 * ```ts
 * const parser = or(str("hello"), str("hello!"));
 *
 * // this will match the first parser
 * const result = parser("hello");
 *
 * // but or returns the untried parsers as a new parser
 * result.nextParser("hello!"); // works
 *
 * // result.nextParser is the same as or(str("hello!"))
 * ```
 *
 * @param parsers - parsers to try
 * @returns - a parser that tries each parser in order. Returns the result of the first parser that succeeds.
 */
function or(...parsers) {
    return trace_trace(`or()`, (input) => {
        for (let i = 0; i < parsers.length; i++) {
            let result = parsers[i](input);
            if (result.success) {
                if (i === parsers.length - 1)
                    return result;
                const nextParser = or(...parsers.slice(i + 1));
                /* console.log({ nextParser }, parsers.slice(i + 1)); */
                return Object.assign(Object.assign({}, result), { nextParser });
            }
        }
        return types_failure(`all parsers failed`, input);
    });
}
/**
 * Takes a parser and runs it. If the parser fails,
 * optional returns a success with a null result.
 *
 * @param parser - parser to run
 * @returns - a parser that runs the given parser.
 * If it fails, returns a success with a null result.
 */
function optional(parser) {
    return trace_trace("optional", (input) => {
        let result = parser(input);
        if (result.success) {
            return result;
        }
        return types_success(null, input);
    });
}
/**
 * Takes a parser and runs it. If the parser fails,
 * `not` returns a success with a `null` result.
 * If the parser succeeds, `not` returns a failure.
 *
 * @param parser - parser to run
 * @returns - a parser that runs the given parser.
 * If it fails, returns a success with a `null` result.
 * If it succeeds, returns a failure.
 */
function not(parser) {
    return trace("not", (input) => {
        let result = parser(input);
        if (result.success) {
            return {
                success: false,
                rest: input,
                message: "expected parser not to succeed",
            };
        }
        return success(null, input);
    });
}
/**
 * Takes three parsers, `open`, `close`, and `parser`.
 * `between` matches multiple instances of `parser`,
 * surrounded by `open` and `close`. It returns the result of `parser`.
 *
 * This is a look-ahead combinator. It keeps trying the `close` parser until it succeeds.
 * That means you can use it like this, and `parser` won't consume the ending quote:
 *
 * ```ts
 * const quotedString = between(quote, quote, anyChar);
 * ```
 *
 * This combinator succeeds even if it parses zero instances of `parser`.
 * So for the above parser, this input would succeed: `""`.
 *
 * If you want it to consume at least one instance of `parser`, use `between1`.
 *
 * Even though this is a look-ahead combinator, it won't work if you supply a greedy parser.
 * You can make the above parser fail simply by adding `many1`:
 *
 * ```ts
 * const quotedString = between(quote, quote, many1(anyChar));
 * ```
 *
 * `many1(anyChar)` will consume all input until the end of the string,
 *  not giving the `close` parser a chance to succeed.
 *
 * This combinator is obviously expensive, as it applies the `close` parser at every step.
 * This combinator can also get into an infinite loop if `parser` succeeds without consuming any input.
 *
 * @param open - parser for the opening delimiter
 * @param close - parser for the closing delimiter
 * @param parser - parser for the content
 * @returns the result of `parser`.
 */
function between(open, close, parser) {
    return (input) => {
        const result1 = open(input);
        if (!result1.success) {
            return result1;
        }
        let rest = result1.rest;
        // keep looking for close
        let result2 = close(rest);
        let successResult = [];
        // while we don't succeed, keep trying to parse with parser
        while (!result2.success) {
            const parserResult = parser(rest);
            // the parser should keep succeeding until we find the closer
            // if it doesn't, we fail
            if (!parserResult.success) {
                return types_failure(parserResult.message, input);
            }
            successResult.push(parserResult.result);
            rest = parserResult.rest;
            result2 = close(rest);
        }
        // we found the closer. Note we consume the closer and return the rest
        return types_success(successResult, result2.rest);
    };
}
/**
 * Like `between`, but fails unless it consumes at least one instance of the `parser`.
 * @param open - parser for the opening delimiter
 * @param close - parser for the closing delimiter
 * @param parser - parser for the content
 * @returns the result of `parser`.
 */
function between1(open, close, parser) {
    return (input) => {
        const result = between(open, close, parser)(input);
        if (result.success) {
            if (result.result.length === 0) {
                return failure("expected at least one match", input);
            }
        }
        return result;
    };
}
/**
 * Parses many instances of the parser separated by separator.
 * The parser will succeed even if it consumes zero instances.
 * To require at least one instance, use `sepBy1`.
 * @param separator
 * @param parser
 * @returns a parser that runs the given parser zero to many times, separated by the separator parser.
 */
function sepBy(separator, parser) {
    return (input) => {
        let results = [];
        let rest = input;
        while (true) {
            const result = parser(rest);
            if (!result.success) {
                return types_success(results, rest);
            }
            results.push(result.result);
            rest = result.rest;
            const sepResult = separator(rest);
            if (!sepResult.success) {
                return types_success(results, rest);
            }
            rest = sepResult.rest;
        }
    };
}
/**
 * Parses many instances of the parser separated by separator.
 * The parser needs to succeed at least once, otherwise sepBy fails.
 * To not require at least one instance, use `sepBy`.
 * @param separator
 * @param parser
 * @returns a parser that runs the given parser one to many times, separated by the separator parser.
 */
function sepBy1(separator, parser) {
    return (input) => {
        const result = sepBy(separator, parser)(input);
        if (result.success) {
            if (result.result.length === 0) {
                return failure("expected at least one match", input);
            }
        }
        return result;
    };
}
/**
 * Convenience function to use as the second argument to `seq` to get all the results from `seq`
 * @param results
 * @param captures
 * @returns `results`
 */
function getResults(results, captures) {
    return results;
}
/**
 * Convenience function to use as the second argument to seq to get all the captures.
 * @param results
 * @param captures
 * @returns `captures`
 */
function getCaptures(results, captures) {
    return captures;
}
/**
 * `capture` is the only way to create a capture. Given a parser and a name,
 * `capture` runs the parser and saves its result in a captures object
 * with the given name as the key. It returns the result from the parser,
 * and attaches the captures object along with it.
 *
 * @param parser - parser to run
 * @param name - name of the capture
 * @returns - the results of the parser, with the captures object attached.
 */
function capture(parser, name) {
    return trace_trace(`capture(${utils_escape(name)})`, (input) => {
        let result = parser(input);
        if (result.success) {
            const captures = {
                [name]: result.result,
            };
            return Object.assign(Object.assign({}, result), { captures });
        }
        return result;
    });
}
/**
 * `captureCaptures` lifts your captures up a level. Suppose you have a parser like this:
 *
 * ```ts
 * const greeting = seqC(
 *   str("hello"),
 *   spaces,
 *   capture(word, "name"),
 *   str("!"),
 *   spaces,
 *   capture(manynTillStr("?"), "secondPart")
 * )
 *
 * This parses a greeting like "hello Adit! How was your day?" into:
 *
 * ```ts
 * {
 *   name: "Adit",
 *   secondPart: "How was your day?"
 * }
 * ```
 *
 * Now, suppose you decide to refactor this parser into two parsers:
 *
 * ```ts
 * const firstPart = seqC(
 *   str("hello"),
 *   spaces,
 *   capture(word, "name"),
 *   str("!")
 * )
 *
 * const secondPart = seqC(
 *   spaces,
 *   capture(manyTillStr("?"), "secondPart")
 * )
 * ```
 *
 * And put them together:
 *
 * ```ts
 * const greeting = seqC(
 *   firstPart,
 *   secondPart
 * )
 * ```
 *
 * Unfortunately, this will no longer return an object in that shape,
 * because it's not actually capturing anything. Captures in `firstPart`
 * and `secondPart` won't get propagated up. Suppose you try to use `capture` like this:
 * ```ts
 * const greeting = seqC(
 *   capture(firstPart, "firstPart"),
 *   capture(secondPart, "secondPart")
 * )
 * ```
 * Now you'll get an object that looks like this instead:
 *
 * ```ts
 * {
 *   firstPart: {
 *     name: "Adit"
 *   },
 *   secondPart: {
 *     secondPart: "How was your day?"
 *   }
 * }
 * ```
 *
 * What you want is for the captures in the child parsers to get merged up to the parent parser. For that, use `captureCaptures`:
 *
 * ```ts
 * const greeting = seqC(
 *   captureCaptures(firstPart),
 *   captureCaptures(secondPart)
 * )
 * ```
 * @param parser - parser to capture captures from
 * @returns - the parser's result set as the captures object
 */
function captureCaptures(parser) {
    const _parser = (input) => {
        let result = parser(input);
        if (result.success) {
            return Object.assign(Object.assign({}, result), { captures: result.result });
        }
        return result;
    };
    return trace_trace(`captureCaptures()`, _parser);
}
/**
 * Returns a parser that consumes input till the given parser succeeds.
 * @param parser - the stop parser
 * @returns a parser that consumes the input string until the stop parser succeeds.
 * Then it returns the consumed input as a string.
 * The stop parser's match is not included in the result.
 */
function manyTill(parser) {
    return (input) => {
        let current = 0;
        while (current < input.length) {
            const parsed = parser(input.slice(current));
            if (parsed.success) {
                return types_success(input.slice(0, current), input.slice(current));
            }
            current++;
        }
        return types_success(input, "");
    };
}
/**
 * Just like `manyTill`, but fails unless at least one character of input is consumed.
 * @param parser - the stop parser
 * @returns a parser that consumes the input string until the stop parser succeeds.
 */
function many1Till(parser) {
    return (input) => {
        let current = 0;
        while (current < input.length) {
            const parsed = parser(input.slice(current));
            if (parsed.success) {
                if (current === 0) {
                    return types_failure("expected to consume at least one character of input", input);
                }
                return types_success(input.slice(0, current), input.slice(current));
            }
            current++;
        }
        if (current === 0) {
            return types_failure("expected to consume at least one character of input", input);
        }
        return types_success(input, "");
    };
}
/**
 * `manyTillOneOf` is an optimized version of `manyTill`.
 * The `manyTill` combinator is slow because it runs the given parser
 * on every character of the string until it succeeds. However, if you
 * just want to consume input until you get to a substring,
 * use `manyTillOneOf`. It uses `indexOf`, which is significantly faster
 * than running a parser over every character.
 *
 * Given an array of strings, this parser consumes input until it hits one of those strings.
 * If none of the strings is found, the parser will consume all input and return success.
 *
 * @param str - the string to stop at
 * @param options - object of optional parameters. { insensitive: boolean }
 * @returns a parser that consumes the input string until one of the given strings is found.
 */
function manyTillOneOf(stops, { insensitive = false } = {}) {
    return trace(`manyTillOneOf(${escape(stops.join(","))})`, (input) => {
        const indexes = [];
        stops.forEach((stop) => {
            const index = insensitive
                ? input.toLocaleLowerCase().indexOf(stop.toLocaleLowerCase())
                : input.indexOf(stop);
            if (index !== -1) {
                indexes.push(index);
            }
        });
        if (indexes.length === 0) {
            return success(input, "");
        }
        const min = Math.min(...indexes);
        return success(input.slice(0, min), input.slice(min));
    });
}
/**
 * `manyTillStr` is an optimized version of `manyTill`.
 * The `manyTill` combinator is slow because it runs the given parser
 * on every character of the string until it succeeds. However, if you
 * just want to consume input until you get to a substring,
 * use `manyTillStr`. It uses `indexOf`, which is significantly faster
 * than running a parser over every character.
 *
 * @param str - the string to stop at
 * @param options - object of optional parameters. { insensitive: boolean }
 * @returns a parser that consumes the input string until the given string is found.
 */
function manyTillStr(str, { insensitive = false } = {}) {
    return trace(`manyTillStr(${escape(str)})`, (input) => {
        return manyTillOneOf([str], { insensitive })(input);
    });
}
/**
 * Like `manyTillStr`, but case insensitive.
 * @param str - the string to stop at
 * @returns a parser that consumes the input string until the given string is found.
 */
function iManyTillStr(str) {
    return manyTillStr(str, { insensitive: true });
}
/**
 * `map` is a parser combinator that takes a parser and a mapper function.
 * If the parser succeeds, it maps its result using the mapper function.
 * You can think of map as a general `map`, like for functors, applied to a parser.
 * Since `map` itself is a parser, you can use it in `seq` or other combinators.
 *
 * @param parser - parser to run
 * @param mapperFunc - function to map the result of the parser
 * @returns
 */
function map(parser, mapperFunc) {
    return trace_trace(`map(${mapperFunc})`, (input) => {
        let parsed = parser(input);
        if (parsed.success) {
            return Object.assign(Object.assign({}, parsed), { result: mapperFunc(parsed.result) });
        }
        return parsed;
    });
}
/**
 * Given a parser that returns a string, `search` looks for all substrings in a string that match that parser.
 * For example, given a parser that matches quoted strings, `search` will return an array of all the quoted strings
 * it finds in the input, as an array.
 *
 * The rest of the input that isn't part of the result is simply joined together and returned as a string.
 * If you need a more structured result + rest, you can use `within` instead.
 *
 * @param parser - the parser to search for
 * @returns - a parser that returns an array of strings
 */
function search(parser) {
    return trace_trace("search", (input) => {
        let parsed = within_within(parser)(input);
        if (parsed.success) {
            const result = parsed.result
                .filter((x) => x.type === "matched")
                .map((x) => x.value);
            const rest = parsed.result
                .filter((x) => x.type === "unmatched")
                .map((x) => x.value)
                .join(" ");
            // @ts-ignore
            return types_success(result, rest);
        }
        return types_success([], input);
    });
}
/*
To add backtracking support requires a fairly big change. Here's an example that needs backtracking.

```ts
  const parser = seq([
        str("hello "),
        or(str("world"), str("world!")),
        optional("?")
    ], getResults);
```

If we try to parse `"hello world!"`, the first parser in the OR will succeed, but then we'll get stuck at the `optional`. Instead, we need to go back up the tree and try the second parser in the OR. A few things need to happen.

1. instead of just processing these parsers sequentially in a for loop, we need to model them as a tree
2. the OR parser needs to let us know that there are other branches to try.

For #2, there's an optional `nextParser` key on a parser success. The or parser can use this to say "a parser succeeded and here's the result, but there are other parsers that could be tried". `nextParser` is a parser that runs the remaining branches. So in this example, the OR would return a success with `nextParser = or(str("world"))`.

Next, we need to model this as a tree. Each node in the tree has a parent and child and the parser for that node.

```ts
  parent: Node;
  parser: GeneralParser<any, any> | null;
  child: Node;
```

Hopefully that is self-explanatory. We start at the root of the tree, try the parser there, then use `.child` to go to the next node and so on. We don't model multiple paths as multiple children. To keep the code simple, we do something else.

Each node also has a `closed` key. Once we've run the parser for a node, we mark it `closed`. Closed means there are no more branches here. UNLESS, the parser returns a `nextParser`. In that case, we *don't* mark it closed because there are still other options to try. In that case, we also *replace* the parser on that node with nextParser.

So, going back to the hello world example, let's say we're stuck at the `optional`:

```ts
  const parser = seq([
        str("hello "),
        or(str("world"), str("world!")),
        optional("?")
    ], getResults);
```

We use `.parent` to go back up the tree. We're looking for a node that isn't closed. If we find one, we start again from there. In this case, we'd find an open node at the or with parser `or(str("world"))`. We can restart from there, but there's a bunch of state to reset.

1. From the new `or` parser, we need to go to the optional parser. We're doing it all again in the same order. This is one reason why it's easier to model this without multiple children. Otherwise, all the children would have to point to the next level, the next level would have to point to all the children in the previous level, and you'd have multiple parents, which is awful to deal with.

2. We have consumed input and added to the results. We need to undo that. At this point, the input is `!`, because we've consumed `hello world`. And the results array is `["hello ", "world"]`. We need to rewind both of those.

To do that, I count how many levels up we've gone to find another branch, and just pop that many elements off the results array. So results is now `["hello "]`. The input is trickier. How would I keep track of what the input was when we were at the OR the last time?

This is where the final key on a tree node comes in. Nodes also have an optional `input` key.

IF a parser succeeds, and
IF there's a nextParser,
We know we may come back to this node. So we save the current input as `.input` on the node.

This approach has some issues. Notably, it doesn't work if you need to backtrack at multiple points in the tree. The test `backtracking-deep.test.ts` shows this.

The code is also complex and it would be easy to have bugs in this logic. I wish there was a cleaner solution for rewinding state.
*/
/**
 * seq takes an array of parsers and runs them sequentially.
 * If any of the parsers fail, seq fails without consuming any input.
 *
 * The second argument to seq is a function.
 * The first argument of that function is an array of results:
 * one result from each of the parsers you gave to seq.
 * The second is an object containing any captures.
 * You can use this second argument, the transformer function,
 * to transform these however you want and return a result
 *
 * Tarsec includes the utility functions `getResults` and `getCaptures`
 * to just return the results array or captures object respectively for you.
 *
 * Finally, you don't need to use seq at all. You can just hand write the logic.
 * But you'll need to do the error handling
 * and pass the remaining input to the next parser yourself.
 * seq also does some backtracking for you that you will need to do yourself.
 *
 * Also see `seqR` and `seqC` for convenience functions that return the results or captures respectively.
 *
 * @param parsers - parsers to run sequentially
 * @param transform - function to transform the results and captures. The params are the results and captures
 * @param debugName - optional name for trace debugging
 * @returns
 */
function seq(parsers, transform, debugName = "") {
    return trace_trace(`seq(${debugName})`, (input) => {
        const results = [];
        let rest = input;
        const captures = {};
        const rootNode = createTree(parsers);
        let current = rootNode;
        while (current) {
            const parser = current.parser;
            if (!parser) {
                console.log({ current, parser, results, captures });
                throw new Error("parser is null");
            }
            const parsed = parser(rest);
            current.closed = true;
            /*       console.log({ parsed }); */
            if (!parsed.success) {
                const [ancestor, count] = findAncestorWithNextParser(current);
                if (ancestor) {
                    current = ancestor;
                    rest = ancestor.input;
                    popMany(results, count);
                    continue;
                }
                else {
                    // don't consume input if we're failing
                    return Object.assign(Object.assign({}, parsed), { rest: input });
                }
            }
            results.push(parsed.result);
            if (parsed.nextParser) {
                /* console.log("setting next parser", parsed.nextParser); */
                current.parser = parsed.nextParser;
                current.input = rest;
                current.closed = false;
            }
            rest = parsed.rest;
            if (isCaptureResult(parsed)) {
                for (const key in parsed.captures) {
                    captures[key] = parsed.captures[key];
                }
            }
            current = current.child;
        }
        const result = transform(results, captures);
        return types_success(result, rest);
    });
}
/** Just like seq except it returns the results.
 * It's like using `seq([parsers], getResults)`.
 */
function seqR(...parsers) {
    return seq(parsers, getResults);
}
/** Just like seq except it returns the captures.
 * It's like using `seq([parsers], getCaptures)`.
 */
function seqC(...parsers) {
    return seq(parsers, getCaptures);
}
/**
 * Match takes an input string and a parser. If the parser matches the input string
 * and consumes the entire input string, `match` returns `true`. Otherwise it returns `false`.
 *
 * @param input - input string
 * @param parser - parser to match input against
 * @returns - true if the parser matches the input and consumes all input, false otherwise
 */
function match(input, parser) {
    const result = parser(input);
    return result.success && result.rest === "";
}
function ifElse(condition, ifParser, elseParser) {
    return trace(`ifElse(${escape(condition)})`, (input) => {
        if (condition) {
            return ifParser(input);
        }
        return elseParser(input);
    });
}
/**
 * Apply multiple parsers to the same input and collect all the results.
 * Consumes no input.
 *
 * @param parsers - parsers to try
 * @returns
 */
function manyParsers(...parsers) {
    return trace(`manyParsers()`, (input) => {
        const results = [];
        for (let i = 0; i < parsers.length; i++) {
            let result = parsers[i](input);
            results.push(result);
        }
        if (results.some(isSuccess)) {
            return success(results, input);
        }
        return failure("no parsers succeeded", input);
    });
}
/**
 * Runs all the given parsers. If they all succeed, returns their results as an array.
 * Otherwise fails. Consumes no input.
 * @param parsers - parsers to try
 * @returns - An array of results, or a failure.
 */
function and(...parsers) {
    return trace(`and()`, (input) => {
        const results = manyParsers(...parsers)(input);
        if (results.success) {
            const successes = results.result.filter(isSuccess);
            if (successes.length === results.result.length) {
                return success(results.result.map((r) => r.result), input);
            }
            return failure("not all parsers succeeded", input);
        }
        return results;
    });
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/tarsec@0.1.1/node_modules/tarsec/dist/parsers.js





/**
 * Takes a character. Returns a parser that parses that character.
 *
 * @param c - character to parse
 * @returns - parser that parses the given character
 */
function parsers_char(c) {
    return trace_trace(`char(${utils_escape(c)})`, (input) => {
        if (input.length === 0) {
            return {
                success: false,
                rest: input,
                message: "unexpected end of input",
            };
        }
        if (input[0] === c) {
            return types_success(c, input.slice(1));
        }
        return types_failure(`expected ${utils_escape(c)}, got ${utils_escape(input[0])}`, input);
    });
}
/**
 * Takes a string. Returns a parser that parses that string.
 *
 * @param s - string to match on
 * @returns - parser that parses the given string
 */
function str(s) {
    return trace_trace(`str(${utils_escape(s)})`, (input) => {
        if (input.substring(0, s.length) === s) {
            return types_success(s, input.slice(s.length));
        }
        return types_failure(`expected ${s}, got ${input.substring(0, s.length)}`, input);
    });
}
/**
 * Like `str`, but case insensitive.
 * @param s - string to match on, case insensitive
 * @returns - parser that matches the given string, case insensitive
 */
function istr(s) {
    return trace(`istr(${escape(s)})`, (input) => {
        if (input.substring(0, s.length).toLocaleLowerCase() === s.toLocaleLowerCase()) {
            return success(input.substring(0, s.length), input.slice(s.length));
        }
        return failure(`expected ${s}, got ${input.substring(0, s.length)}`, input);
    });
}
/**
 * Takes a string. Returns a parser that parses
 * one of the characters in that string.
 *
 * @param chars - string of possible characters
 * @returns - parser that parses one of the given characters
 */
function oneOf(chars) {
    return trace_trace(`oneOf(${utils_escape(chars)})`, (input) => {
        if (input.length === 0) {
            return types_failure("unexpected end of input", input);
        }
        const c = input[0];
        if (chars.includes(c)) {
            return parsers_char(c)(input);
        }
        return types_failure(`expected one of ${utils_escape(chars)}, got ${c}`, input);
    });
}
/**
 * Takes a string. Returns a parser that parses one character
 * that's not any of the characters in the given string
 *
 * @param chars - string of characters to avoid
 * @returns - parser that parses a character that is not in the given string
 */
function noneOf(chars) {
    return trace_trace(`noneOf(${utils_escape(chars)})`, (input) => {
        if (input.length === 0) {
            return types_failure("unexpected end of input", input);
        }
        if (chars.includes(input[0])) {
            return types_failure(`expected none of ${utils_escape(chars)}, got ${input[0]}`, input);
        }
        return parsers_char(input[0])(input);
    });
}
/**
 * A parser that parses any one character.
 * Fails on empty strings, succeeds otherwise.
 *
 * @param input - input string
 * @returns - ParserResult
 */
const anyChar = trace_trace("anyChar", (input) => {
    if (input.length === 0) {
        return types_failure("unexpected end of input", input);
    }
    return types_success(input[0], input.slice(1));
});
/** A parser that matches one of " \t\n\r". */
const space = oneOf(" \t\n\r");
/** A parser that matches one or more spaces. */
const spaces = many1WithJoin(space);
/** A parser that matches one digit. */
const digit = oneOf("0123456789");
/** A parser that matches one letter, case insensitive. */
const letter = oneOf("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
/** A parser that matches one digit or letter, case insensitive. */
const alphanum = oneOf("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
/** A parser that matches one word, case insensitive. */
const word = regexParser("^[a-z]+", "ui");
/** A parser that matches one or more digits. */
const num = regexParser("^[0-9]+");
/** A parser that matches one single or double quote. */
const quote = oneOf(`'"`);
/** A parser that matches one tab character. */
const tab = parsers_char("\t");
/** A parser that matches one newline ("\n" only) character. */
const newline = parsers_char("\n");
/** A parser that succeeds on an empty string. Returns `null` as the result. */
const eof = (input) => {
    if (input === "") {
        return types_success(null, input);
    }
    return types_failure("expected end of input", input);
};
/** A parser that matches a quoted string, in single or double quotes.
 * Returns the string as the result, including the quotes.
 */
const quotedString = seq([quote, manyWithJoin(noneOf(`"'`)), quote], (results) => results.join(""));
/**
 * Returns a parser that matches a regex. If you pass in a string,
 * it will get converted to a regex. The regex should always match from the start of the input.
 * If you pass in a string, a `^` will get prepended to it.
 *
 * @param str - regex string or RegExp instance to match
 * @param options - regex options (i = ignore case, g = global, m = multiline, u = unicode)
 * @returns - parser that matches the given regex
 */
function regexParser(str, options = "") {
    let re;
    if (typeof str === "string") {
        re = new RegExp(str.startsWith("^") ? str : `^${str}`, options);
    }
    else {
        re = str;
    }
    return trace_trace(`regex(${str})`, (input) => {
        const match = input.match(re);
        if (match) {
            return types_success(match[0], input.slice(match[0].length));
        }
        return types_failure(`expected ${str}, got ${input.slice(0, 10)}`, input);
    });
}
/**
 * Like `regexParser`, but you can name your capture groups
 * and get them back as the result instead.
 * Fails if it doesn't have the same number of names as capture groups.
 *
 * @param str - regex string or RegExp instance to match
 * @param options - string of regex options (i = ignore case, g = global, m = multiline, u = unicode)
 * @param captureNames - names of the captures
 * @returns - parser that matches the given regex
 */
function captureRegex(str, options = "", ...captureNames) {
    let re;
    if (typeof str === "string") {
        re = new RegExp(str.startsWith("^") ? str : `^${str}`, options);
    }
    else {
        re = str;
    }
    const _parser = (input) => {
        const match = input.match(re);
        if (match) {
            if (match.slice(1).length > captureNames.length) {
                return failure(`more capture groups than names. ${match.slice(1).length} capture groups, ${captureNames.length} names`, input);
            }
            if (match.slice(1).length < captureNames.length) {
                return failure(`fewer capture groups than names. ${match.slice(1).length} capture groups, ${captureNames.length} names`, input);
            }
            const captures = Object.assign({}, Object.fromEntries(match.slice(1).map((value, index) => [captureNames[index], value])));
            return success(captures, input.slice(match[0].length));
        }
        return failure(`expected ${str}, got ${input.slice(0, 10)}`, input);
    };
    return trace(`captureRegex(${str})`, _parser);
}
/**
 * Return a parser that takes a key and a value.
 * The parser consumes no input and always succeeds,
 * and returns `null` as the result. It also returns a captures object
 * with that key-value pair set. This is useful when you need to inject
 * a key-value pair into captures for a `seq`.
 *
 * For example, here is a Markdown heading parser.

 * ```ts
 * export const headingParser: Parser<Heading> = seqC(
 *   capture(count(char("#")), "level"),
 *   spaces,
 *   capture(many1Till(or(char("\n"), eof)), "content")
 * );
```
 *
 * This parser returns
 *
 * ```ts
 * {
 *   level: number,
 *   content: string
 * }
 * ```
 * but the type of heading is actually
 *
 * ```ts
 * type Heading = {
 *   type: "heading";
 *   level: number;
 *   content: string;
 * };
 * ```
 *
 * The `type` key is missing. You can use `set` to inject the `type`
 * key-value pair into captures:
 *
 * ```ts
 * export const headingParser: Parser<Heading> = seqC(
 *   set("type", "heading"),
 *   capture(count(char("#")), "level"),
 *   spaces,
 *   capture(many1Till(or(char("\n"), eof)), "content")
 * );
 * ```
 *
 * @param key - key to set on captures object
 * @param value - value to set on captures object
 * @returns
 */
function set(key, value) {
    return trace_trace(`set(${key}, ${value})`, (input) => {
        return captureSuccess(null, input, { [key]: value });
    });
}
/**
 * A parser that always succeeds with the given value.
 * @param value - value to succeed with
 * @returns value
 */
function succeed(value) {
    return trace_trace(`succeed(${value})`, (input) => {
        return types_success(value, input);
    });
}
/**
 * A parser that always fails with the given message.
 * @param message - message to fail with
 * @returns failure
 */
function fail(message) {
    return trace(`fail(${message})`, (input) => {
        return failure(message, input);
    });
}
/**
 * Takes a string. Succeeds if the given input contains that string.
 * Consumes no input.
 *
 * @param substr - substring to find
 * @returns - parser that succeeds if the given input contains that string
 */
function includes(substr) {
    return trace(`includes(${substr})`, (input) => {
        if (input.includes(substr)) {
            return success(substr, input);
        }
        return failure(`expected ${escape(input)} to include ${escape(substr)}`, input);
    });
}
/**
 * Like `includes`, but case-insensitive.
 *
 * @param substr - substring to find
 * @returns - parser that succeeds if the given input contains that string
 */
function iIncludes(substr) {
    return trace(`iIncludes(${substr})`, (input) => {
        if (input.toLowerCase().includes(substr.toLowerCase())) {
            return success(substr, input);
        }
        return failure(`expected "${input}" to include "${substr}" (case-insensitive)`, input);
    });
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/tarsec@0.1.1/node_modules/tarsec/dist/index.js





;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/parsers/utils.js

const optionalSpaces = many(space);
const backtick = parsers_char("`");
const comma = seqR(optionalSpaces, parsers_char(","), optionalSpaces);
const varNameChar = oneOf("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_");

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/parsers/parserUtils.js

const optionalSemicolon = optional(parsers_char(";"));

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/parsers/typeHints.js



const primitiveTypeParser = trace_trace("primitiveTypeParser", seqC(set("type", "primitiveType"), capture(or(str("number"), str("string"), str("boolean")), "value")));
const typeAliasVariableParser = trace_trace("typeAliasVariableParser", seqC(set("type", "typeAliasVariable"), capture(many1WithJoin(varNameChar), "aliasName")));
const arrayTypeParser = (input) => {
    const parser = trace_trace("arrayTypeParser", seqC(set("type", "arrayType"), capture(or(objectTypeParser, primitiveTypeParser), "elementType"), capture(count(str("[]")), "arrayDepth")));
    const result = parser(input);
    if (result.success) {
        // Wrap the elementType in ArrayType according to arrayDepth
        let wrappedType = result.result.elementType;
        for (let i = 0; i < result.result.arrayDepth; i++) {
            wrappedType = {
                type: "arrayType",
                elementType: wrappedType,
            };
        }
        return {
            success: true,
            rest: result.rest,
            result: wrappedType,
        };
    }
    return result;
};
const angleBracketsArrayTypeParser = trace_trace("angleBracketsArrayTypeParser", seqC(set("type", "arrayType"), str("array"), parsers_char("<"), capture(primitiveTypeParser, "elementType"), parsers_char(">")));
const stringLiteralTypeParser = trace_trace("stringLiteralTypeParser", seqC(set("type", "stringLiteralType"), parsers_char('"'), capture(many1Till(parsers_char('"')), "value"), parsers_char('"')));
const numberLiteralTypeParser = trace_trace("numberLiteralTypeParser", seqC(set("type", "numberLiteralType"), capture(many1WithJoin(or(parsers_char("-"), parsers_char("."), digit)), "value")));
const booleanLiteralTypeParser = trace_trace("booleanLiteralTypeParser", seqC(set("type", "booleanLiteralType"), capture(or(str("true"), str("false")), "value")));
const objectPropertyDelimiter = seqR(optionalSpaces, parsers_char(";"), optionalSpaces);
const objectPropertyParser = trace_trace("objectPropertyParser", (input) => {
    const parser = seqC(capture(many1WithJoin(varNameChar), "key"), optionalSpaces, parsers_char(":"), optionalSpaces, capture(variableTypeParser, "value"));
    return parser(input);
});
const objectPropertyDescriptionParser = seqC(parsers_char("#"), optionalSpaces, capture(many1Till(parsers_char(";")), "description"));
const objectPropertyWithDescriptionParser = trace_trace("objectPropertyWithDescriptionParser", seqC(captureCaptures(objectPropertyParser), spaces, captureCaptures(objectPropertyDescriptionParser)));
const objectTypeParser = trace_trace("objectTypeParser", (input) => {
    const parser = seqC(set("type", "objectType"), parsers_char("{"), optionalSpaces, capture(sepBy(objectPropertyDelimiter, or(objectPropertyWithDescriptionParser, objectPropertyParser)), "properties"), optionalSpaces, parsers_char("}"));
    return parser(input);
});
const unionItemParser = trace_trace("unionItemParser", or(objectTypeParser, angleBracketsArrayTypeParser, arrayTypeParser, stringLiteralTypeParser, numberLiteralTypeParser, booleanLiteralTypeParser, primitiveTypeParser, typeAliasVariableParser));
const pipe = seqR(optionalSpaces, str("|"), optionalSpaces);
const _unionTypeParser = (input) => {
    const parser = seqC(set("type", "unionType"), capture(sepBy(pipe, unionItemParser), "types"));
    const result = parser(input);
    // Union types must have at least 2 types (i.e., at least one "|")
    if (result.success && result.result.types.length < 2) {
        return {
            success: false,
            rest: input,
            message: "Union type must have at least 2 types",
        };
    }
    return result;
};
const unionTypeParser = trace_trace("unionTypeParser", _unionTypeParser);
const variableTypeParser = trace_trace("variableTypeParser", or(unionTypeParser, arrayTypeParser, objectTypeParser, angleBracketsArrayTypeParser, stringLiteralTypeParser, numberLiteralTypeParser, booleanLiteralTypeParser, primitiveTypeParser, typeAliasVariableParser));
const typeHintParser = trace_trace("typeHintParser", seqC(set("type", "typeHint"), capture(many1Till(space), "variableName"), optionalSpaces, str("::"), optionalSpaces, capture(variableTypeParser, "variableType"), optionalSemicolon));
const typeAliasParser = trace_trace("typeAliasParser", seqC(set("type", "typeAlias"), str("type"), spaces, capture(many1WithJoin(varNameChar), "aliasName"), optionalSpaces, str("="), optionalSpaces, capture(variableTypeParser, "aliasedType"), optionalSemicolon));

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/parsers/literals.js


const textSegmentParser = map(many1Till(or(backtick, parsers_char("$"))), (text) => ({
    type: "text",
    value: text,
}));
const interpolationSegmentParser = seqC(set("type", "interpolation"), parsers_char("$"), parsers_char("{"), capture(many1Till(parsers_char("}")), "variableName"), parsers_char("}"));
const promptParser = seqC(set("type", "prompt"), backtick, capture(many(or(textSegmentParser, interpolationSegmentParser)), "segments"), backtick);
const numberParser = seqC(set("type", "number"), capture(many1WithJoin(or(parsers_char("-"), parsers_char("."), digit)), "value"));
const stringParser = seqC(set("type", "string"), parsers_char('"'), capture(manyTill(parsers_char('"')), "value"), parsers_char('"'));
const variableNameParser = seqC(set("type", "variableName"), capture(many1WithJoin(varNameChar), "value"));
const literalParser = or(promptParser, numberParser, stringParser, variableNameParser);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/parsers/functionCall.js





const functionCall_comma = seqR(optionalSpaces, parsers_char(","), optionalSpaces);
const functionCallParser = (input) => {
    const parser = seqC(set("type", "functionCall"), capture(many1WithJoin(varNameChar), "functionName"), parsers_char("("), optionalSpaces, capture(sepBy(functionCall_comma, or(functionCallParser, accessExpressionParser, literalParser)), "arguments"), optionalSpaces, parsers_char(")"), optionalSemicolon);
    return parser(input);
};

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/parsers/dataStructures.js





const agencyArrayParser = (input) => {
    const parser = trace_trace("agencyArrayParser", seqC(set("type", "agencyArray"), parsers_char("["), capture(sepBy(comma, or(accessExpressionParser, functionCallParser, literalParser, agencyObjectParser, agencyArrayParser)), "items"), parsers_char("]")));
    return parser(input);
};
const agencyObjectKVParser = (input) => {
    const parser = trace_trace("agencyObjectKVParser", seqC(optionalSpaces, optional(parsers_char('"')), capture(manyWithJoin(noneOf('":\n\t ')), "key"), optional(parsers_char('"')), optionalSpaces, parsers_char(":"), optionalSpaces, capture(or(accessExpressionParser, functionCallParser, literalParser, agencyObjectParser, agencyArrayParser), "value")));
    return parser(input);
};
const agencyObjectParser = seqC(set("type", "agencyObject"), parsers_char("{"), optionalSpaces, capture(or(sepBy(comma, agencyObjectKVParser), succeed([])), "entries"), optional(parsers_char(",")), optionalSpaces, parsers_char("}"));

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/parsers/access.js






const dotPropertyParser = (input) => {
    const parser = seqC(set("type", "dotProperty"), capture(or(literalParser, functionCallParser), "object"), parsers_char("."), capture(many1WithJoin(varNameChar), "propertyName"));
    return parser(input);
};
const indexAccessParser = (input) => {
    const parser = seqC(set("type", "indexAccess"), capture(or(agencyArrayParser, functionCallParser, literalParser), "array"), parsers_char("["), capture(or(functionCallParser, literalParser), "index"), parsers_char("]"));
    return parser(input);
};
const dotFunctionCallParser = (input) => {
    const parser = seqC(set("type", "dotFunctionCall"), capture(or(functionCallParser, literalParser), "object"), parsers_char("."), capture(functionCallParser, "functionCall"));
    return parser(input);
};
const accessExpressionParser = seqC(set("type", "accessExpression"), capture(or(dotFunctionCallParser, dotPropertyParser, indexAccessParser), "expression"), optionalSemicolon);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/parsers/assignment.js







const assignmentParser = trace_trace("assignmentParser", seqC(set("type", "assignment"), optionalSpaces, capture(many1WithJoin(varNameChar), "variableName"), optionalSpaces, parsers_char("="), optionalSpaces, capture(or(functionCallParser, accessExpressionParser, agencyArrayParser, agencyObjectParser, literalParser), "value"), optionalSemicolon));

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/parsers/comment.js


const commentParser = (input) => {
    const parser = seqC(set("type", "comment"), optionalSpaces, str("//"), capture(many1Till(newline), "content"));
    return parser(input);
};

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/parsers/returnStatement.js







const returnStatementParser = seqC(set("type", "returnStatement"), str("return"), optionalSpaces, capture(or(accessExpressionParser, functionCallParser, literalParser, agencyObjectParser, agencyArrayParser), "value"), optionalSemicolon);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/parsers/matchBlock.js
/*
export type MatchBlock = {
  type: "matchBlock";
  expression: Literal;
  cases: Array<{
    caseValue: Literal;
    body: Assignment | Literal | FunctionCall;
  }>;
};
*/










const defaultCaseParser = parsers_char("_");
const matchBlockParserCase = seqC(set("type", "matchBlockCase"), optionalSpaces, capture(or(defaultCaseParser, accessExpressionParser, literalParser), "caseValue"), optionalSpaces, str("=>"), optionalSpaces, capture(or(returnStatementParser, agencyArrayParser, agencyObjectParser, accessExpressionParser, assignmentParser, functionCallParser, literalParser), "body"));
const semicolon = seqC(optionalSpaces, parsers_char(";"), optionalSpaces);
const matchBlockParser = seqC(set("type", "matchBlock"), str("match"), optionalSpaces, parsers_char("("), capture(literalParser, "expression"), parsers_char(")"), optionalSpaces, parsers_char("{"), optionalSpaces, capture(sepBy(or(semicolon, newline), or(commentParser, matchBlockParserCase)), "cases"), optionalSpaces, parsers_char("}"), optionalSemicolon);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/parsers/tools.js


const usesToolParser = seqC(set("type", "usesTool"), parsers_char("+"), capture(many1WithJoin(varNameChar), "toolName"));

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/parsers/function.js












const trim = (s) => s.trim();
const docStringParser = trace_trace("docStringParser", seqC(set("type", "docString"), str('"""'), capture(map(many1Till(str('"""')), trim), "value"), str('"""')));
const bodyParser = trace_trace("functionBodyParser", (input) => {
    const parser = sepBy(spaces, or(usesToolParser, debug(typeAliasParser, "error in typeAliasParser"), debug(typeHintParser, "error in typeHintParser"), returnStatementParser, whileLoopParser, matchBlockParser, functionParser, accessExpressionParser, assignmentParser, functionCallParser, literalParser, commentParser));
    const result = parser(input);
    return result;
});
const whileLoopParser = trace_trace("whileLoopParser", seqC(set("type", "whileLoop"), str("while"), optionalSpaces, parsers_char("("), optionalSpaces, capture(or(functionCallParser, accessExpressionParser, literalParser), "condition"), optionalSpaces, parsers_char(")"), optionalSpaces, parsers_char("{"), spaces, capture(bodyParser, "body"), optionalSpaces, parsers_char("}")));
const functionParser = trace_trace("functionParser", seqC(set("type", "function"), str("def"), many1(space), capture(many1Till(parsers_char("(")), "functionName"), parsers_char("("), optionalSpaces, capture(sepBy(comma, many1WithJoin(varNameChar)), "parameters"), optionalSpaces, parsers_char(")"), optionalSpaces, parsers_char("{"), optionalSpaces, capture(or(docStringParser, succeed(undefined)), "docString"), optionalSpaces, capture(bodyParser, "body"), optionalSpaces, parsers_char("}"), optionalSemicolon));
const graphNodeParser = trace_trace("graphNodeParser", seqC(set("type", "graphNode"), str("node"), many1(space), capture(many1Till(parsers_char("(")), "nodeName"), parsers_char("("), optionalSpaces, capture(or(sepBy(comma, many1WithJoin(varNameChar)), succeed([])), "parameters"), optionalSpaces, parsers_char(")"), optionalSpaces, parsers_char("{"), optionalSpaces, capture(bodyParser, "body"), optionalSpaces, parsers_char("}"), optionalSemicolon));

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/parsers/importStatement.js


const importStatmentParser = trace_trace("importStatement", seqC(set("type", "importStatement"), str("import"), spaces, capture(many1Till(str("from")), "importedNames"), str("from"), spaces, capture(many1Till(oneOf(";\n")), "modulePath"), optionalSemicolon));

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/parser.js











const agencyNode = (input) => {
    const parser = sepBy(spaces, trace_trace("agencyParser", or(usesToolParser, importStatmentParser, graphNodeParser, typeAliasParser, whileLoopParser, typeHintParser, matchBlockParser, functionParser, returnStatementParser, accessExpressionParser, assignmentParser, functionCallParser, commentParser)));
    return parser(input);
};
const agencyParser = seqC(set("type", "agencyProgram"), capture(agencyNode, "nodes"), eof);
const _multilineCommentParser = between(str("/*"), str("*/"), anyChar);
const multilineCommentParser = search(_multilineCommentParser);
function parseAgency(input) {
    let normalized = input;
    const comments = multilineCommentParser(normalized);
    // get rid of all multiline comments
    normalized = comments.rest
        .split("\n")
        .map((line) => {
        return line.trim();
    })
        .filter((l) => l.length > 0)
        .join("\n");
    if (normalized.trim().length === 0) {
        return types_success({
            type: "agencyProgram",
            nodes: [],
        }, "");
    }
    const result = agencyParser(normalized);
    return result;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/backends/baseGenerator.js
class BaseGenerator {
    typeHints = {};
    graphNodes = [];
    generatedStatements = [];
    generatedTypeAliases = [];
    functionScopedVariables = [];
    // collect tools for a prompt
    toolsUsed = [];
    typeAliases = {};
    // collect functions used to see what builtin helpers to include
    functionsUsed = new Set();
    importStatements = [];
    // collect function signatures so we can implement named args
    functionSignatures = {};
    constructor() { }
    generate(program) {
        // Pass 1: Collect all type aliases
        for (const node of program.nodes) {
            if (node.type === "typeAlias") {
                this.processTypeAlias(node);
            }
        }
        // Pass 2: Collect all type hints
        for (const node of program.nodes) {
            if (node.type === "typeHint") {
                this.processTypeHint(node);
            }
        }
        // Pass 3: Collect all node names
        for (const node of program.nodes) {
            if (node.type === "graphNode") {
                this.processGraphNodeName(node);
            }
        }
        // Pass 4: Generate code for tools
        for (const node of program.nodes) {
            if (node.type === "function") {
                this.generatedStatements.push(this.processTool(node));
                this.collectFunctionSignature(node);
            }
        }
        // Pass 5: Process all nodes and generate code
        for (const node of program.nodes) {
            const result = this.processNode(node);
            this.generatedStatements.push(result);
        }
        const output = [];
        output.push(this.preprocess() + "\n");
        output.push(this.importStatements.join("\n") + "\n");
        output.push(this.generateImports() + "\n");
        output.push(this.generateBuiltins() + "\n");
        output.push("\n");
        output.push(...this.generatedTypeAliases);
        output.push(this.generatedStatements.join(""));
        output.push(this.postprocess() + "\n");
        return {
            output: output.filter(Boolean).join("\n"),
        };
    }
    generateBuiltins() {
        return "";
    }
    processTypeAlias(node) {
        // subclasses implement this
        return "";
    }
    processTypeHint(node) {
        // subclasses implement this
        return "";
    }
    collectFunctionSignature(node) {
        this.functionSignatures[node.functionName] = node.parameters;
    }
    processGraphNodeName(node) { }
    processNode(node) {
        switch (node.type) {
            case "typeHint":
                return this.processTypeHint(node);
            case "typeAlias":
                return this.processTypeAlias(node);
            case "assignment":
                return this.processAssignment(node);
            case "function":
                return this.processFunctionDefinition(node);
            case "functionCall":
                return this.processFunctionCall(node);
            case "accessExpression":
                return this.processAccessExpression(node);
            case "comment":
                return this.processComment(node);
            case "matchBlock":
                return this.processMatchBlock(node);
            case "number":
            case "string":
            case "variableName":
            case "prompt":
                // Standalone literals at top level
                return this.generateLiteral(node);
            case "returnStatement":
                return this.processReturnStatement(node);
            case "agencyArray":
                return this.processAgencyArray(node);
            case "agencyObject":
                return this.processAgencyObject(node);
            case "graphNode":
                return this.processGraphNode(node);
            case "usesTool":
                return this.processUsesTool(node);
            case "importStatement":
                this.importStatements.push(this.processImportStatement(node));
                return "";
            case "whileLoop":
                return this.processWhileLoop(node);
            default:
                throw new Error(`Unhandled Agency node type: ${node.type}`);
        }
    }
    processWhileLoop(node) {
        return "processWhileLoop not implemented";
    }
    processImportStatement(node) {
        return "processImportStatement not implemented";
    }
    processTool(node) {
        return "processTool not implemented";
    }
    processUsesTool(node) {
        return "processUsesTool not implemented";
    }
    processGraphNode(node) {
        return "processGraphNode not implemented";
    }
    processAgencyObject(node) {
        return "<processAgencyObject not implemented>";
    }
    processAgencyArray(node) {
        return "<processAgencyArray not implemented>";
    }
    processComment(node) {
        return "processComment not implemented";
    }
    processReturnStatement(node) {
        return "processReturnStatement not implemented";
    }
    processAccessExpression(node) {
        switch (node.expression.type) {
            case "dotProperty":
                return this.processDotProperty(node.expression);
            case "indexAccess":
                return this.processIndexAccess(node.expression);
            case "dotFunctionCall":
                return this.processDotFunctionCall(node.expression);
        }
    }
    processMatchBlock(node) {
        return "processMatchBlock not implemented";
    }
    processDotProperty(node) {
        return "processDotProperty not implemented";
    }
    processDotFunctionCall(node) {
        return "processDotFunctionCall not implemented";
    }
    processIndexAccess(node) {
        return "processIndexAccess not implemented";
    }
    processAssignment(node) {
        return "processAssignment not implemented";
    }
    processPromptLiteral(variableName, node) {
        return "processPromptLiteral not implemented";
    }
    processFunctionDefinition(node) {
        return "processFunctionDefinition not implemented";
    }
    processFunctionCall(node) {
        return "processFunctionCall not implemented";
    }
    generateFunctionCallExpression(node) {
        return "generateFunctionCallExpression not implemented";
    }
    generateLiteral(literal) {
        return "generateLiteral not implemented";
    }
    generateImports() {
        return "generateImports not implemented";
    }
    preprocess() {
        return "";
    }
    postprocess() {
        return "";
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/tarsec@0.0.18/node_modules/tarsec/dist/utils.js
function dist_utils_escape(str) {
    return JSON.stringify(str);
}
function utils_merge(a, b) {
    if (Array.isArray(a) && Array.isArray(b)) {
        return [...a, ...b];
    }
    else if (Array.isArray(a)) {
        return [...a, b];
    }
    else if (Array.isArray(b)) {
        return [a, ...b];
    }
    else {
        return [a, b];
    }
}
function utils_mergeCaptures(a, b) {
    const result = {};
    Object.keys(a).forEach((key) => {
        result[key] = a[key];
    });
    Object.keys(b).forEach((key) => {
        if (result[key]) {
            result[key] = utils_merge(result[key], b[key]);
        }
        else {
            result[key] = b[key];
        }
    });
    return result;
}
function utils_findAncestorWithNextParser(node, count = 0) {
    if (node === null)
        return [null, count];
    if (!node.closed) {
        return [node, count];
    }
    if (node.parent) {
        return utils_findAncestorWithNextParser(node.parent, count + 1);
    }
    return [null, count];
}
function utils_popMany(arr, count) {
    for (let i = 0; i < count; i++) {
        arr.pop();
    }
}
function dist_utils_round(num, places = 2) {
    return Math.round(num * 10 ** places) / 10 ** places;
}
function utils_shorten(str, length = 250) {
    if (str.length > length) {
        return str.substring(0, length) + "...";
    }
    return str;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/tarsec@0.0.18/node_modules/tarsec/dist/trace.js


const trace_STEP = 2;
/**
 * This function is used internally by the `trace` function to create the string for each step.
 * @param name - debug name for parser
 * @param result - parser result
 * @returns - A formatted string that describes the parser's result
 */
function trace_resultToString(name, result) {
    if (result.success) {
        return ` ${name} -- match: ${dist_utils_escape(result.result)}, rest: ${dist_utils_escape(result.rest)}`;
    }
    return ` ${name} -- message: ${dist_utils_escape(result.message)}, rest: ${dist_utils_escape(result.rest)}`;
}
let trace_level = 0;
let trace_counts = {};
let trace_times = {};
let trace_debugFlag = !!external_process_namespaceObject.env.DEBUG;
let trace_stepCount = 0;
let trace_stepLimit = -1;
/**
 * This function is used internally with debug mode. Given a parser and a debug name for it,
 * when the parser is called, `trace` will:
 * 1. Print a line when the parser starts
 * 2. print a line when the parser ends, indicating success or failure.
 * 3. If the parser returns any captures, print the captures.
 * 4. Count the number of times this parser has been run.
 * 5. Track the total time this parser has taken.
 * 6. Track the total number of steps your parser has taken (a step equals one parser invocation).
 * So, for example, you may find out that your parser to parse Markdown has taken 50 steps to parse that file.
 *
 * All this happens only if debug mode is on, which you can turn on by using `parserDebug`, or setting the env var `DEBUG` to `1`.
 *
 * Caveat: If you have debug mode on through an environment variable, `trace` will capture counts and times
 * for all parsers across your entire application. If you want to profile just a particular section of code, use `parserDebug` instead.
 * If you *do* want to track constant times for all parsers, don't use `parserDebug` as it will reset those.
 *
 *
 * `trace` works with tarsec's built-in parsers out of the box. You can easily set it up to work with your custom parser too.
 *
 * For example, if your parser looks like this:
 *
 * ```ts
 * const myParser = (input:string) => {
 *   if (input === "hello") {
 *    return { success: true, result: "hello", rest: "" };
 *  }
 * return { success: false, message: "expected hello", rest: input };
 * }
 * ```
 *
 * You can wrap it in `trace` like this:
 *
 * ```ts
 * const myParser = trace("myParser", (input:string) => {
 *  if (input === "hello") {
 *   return { success: true, result: "hello", rest: "" };
 * }
 * return { success: false, message: "expected hello", rest: input };
 * });
 * ```
 *
 * Now, when you run `myParser("hello")` with debug mode on,
 * you will see the debug output.
 *
 * Some parsers, like `seq`, are very general. You might have a few parser that use `seq`.
 * So when you see `seq` debug output, you might not know which `seq` parser that means.
 * ou can pass `seq` a debug name as an optional third argument to be used in the debug output.
 * This name is used to track count and time, so using this name will also mean this `seq` parser's
 * count and time are tracked separately from the other `seq` parsers, which might be useful.
 *
 * @param name - debug name for parser
 * @param parser - parser to run
 * @returns
 */
function dist_trace_trace(name, parser) {
    if (trace_stepLimit > 0 && trace_stepCount > trace_stepLimit) {
        throw new Error(`parser step limit of ${trace_stepLimit} exceeded, parser may be in an infinite loop`);
    }
    return (input) => {
        if (trace_debugFlag) {
            console.log(" ".repeat(trace_level) + ` ${name} -- input: ${utils_shorten(dist_utils_escape(input))}`);
            let result;
            const time = trace_parserTime(() => {
                trace_level += trace_STEP;
                result = parser(input);
                trace_level -= trace_STEP;
            });
            trace_counts[name] = trace_counts[name] ? trace_counts[name] + 1 : 1;
            trace_stepCount += 1;
            if (time) {
                trace_times[name] = trace_times[name] ? trace_times[name] + time : time;
            }
            console.log(" ".repeat(trace_level) + trace_resultToString(name, result));
            if (result.success && result.captures) {
                console.log(" ".repeat(trace_level) +
                    ` ${name} -- captures: ${JSON.stringify(result.captures)}`);
            }
            return result;
        }
        else {
            return parser(input);
        }
    };
}
/**
 * Utility timing function. Given a callback, it times the callback
 * and returns its runtime in milliseconds. It uses `performance.now()` to do this.
 * If `performance.now()` is not available, it returns null.
 *
 * @param callback - callback to time
 * @returns - time in milliseconds
 */
function trace_parserTime(callback) {
    if (performance && performance.now) {
        const start = performance.now();
        callback();
        const end = performance.now();
        return end - start;
    }
    else {
        console.error("performance.now not available");
        callback();
        return null;
    }
}
/**
 * Wrapper for parser time. Instead of returning the time in milliseconds,
 * it console.logs it, in a nicely formatted string.
 * @param name - debug name for timing
 * @param callback - callback to time
 */
function trace_printTime(name, callback) {
    const time = trace_parserTime(callback);
    if (time) {
        console.log(` ${name} -- time: ${round(time)}ms`);
    }
}
/**
 * This is the recommended way to run a parser in debug mode.
 * Takes a callback and turns debug mode on just for the callback.
 * This enables `trace` to capture all sorts of information
 * about any executed parsers and print them to console.log.
 * `trace` tracks counts and times but they don't actually get reset to zero
 * unless you use this function to wrap your code.
 *
 * @param name - debug name
 * @param callback - callback to run in debug mode
 */
function trace_parserDebug(name, callback) {
    trace_debugFlag = true;
    trace_stepCount = 0;
    trace_counts = {};
    trace_times = {};
    trace_printTime(name, callback);
    trace_debugFlag = false;
    console.log("\n");
    console.log(` ${name} -- counts:`);
    const sorted = Object.entries(trace_counts).sort((a, b) => b[1] - a[1]);
    for (const [name, count] of sorted) {
        console.log(`  ${name}: ${count}`);
    }
    console.log("\n");
    console.log(` ${name} -- times:`);
    const sortedTimes = Object.entries(trace_times).sort((a, b) => b[1] - a[1]);
    for (const [name, time] of sortedTimes) {
        console.log(`  ${name}: ${round(time)}ms`);
    }
    console.log("\n");
    console.log(` ${name} -- step count: ${trace_stepCount}`);
    console.log("\n\n");
    trace_stepCount = 0;
    trace_counts = {};
    trace_times = {};
}
/**
 * Utility function to limit the number of steps a parser can take.
 * This is useful for avoiding infinite loops in your parser.
 * @param limit - number of steps to limit the parser to
 * @param callback - callback to run
 */
function trace_limitSteps(limit, callback) {
    trace_stepLimit = limit;
    callback();
    trace_stepLimit = -1;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/tarsec@0.0.18/node_modules/tarsec/dist/parsers/within.js


function parsers_within_within(parser) {
    return trace("within", (input) => {
        let start = 0;
        let current = 0;
        const results = [];
        while (current < input.length) {
            const parsed = parser(input.slice(current));
            if (parsed.success) {
                const unmatchedValue = input.slice(start, current);
                if (unmatchedValue.length > 0) {
                    results.push({
                        type: "unmatched",
                        value: unmatchedValue,
                    });
                }
                results.push({
                    type: "matched",
                    value: parsed.result,
                });
                current += parsed.result.length;
                start = current;
            }
            else {
                current += 1;
            }
        }
        if (start < current) {
            results.push({
                type: "unmatched",
                value: input.slice(start, current),
            });
        }
        return success(results, "");
    });
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/tarsec@0.0.18/node_modules/tarsec/dist/types.js
function types_isCaptureResult(result) {
    return "captures" in result;
}
/**
 * This typed function is helpful in filtering out the successes
 * from an array of results while preserving type information. For example:
 *
 * ```
 * // type is ParserSuccess[]
 * results.filter(isSuccess);
 *
 * // type is ParserResult[]
 * results.filter(r => r.success);
 * ```
 * @param result - a parser result
 * @returns - true if the result is a success, otherwise false
 */
function dist_types_isSuccess(result) {
    return result.success;
}
/** Convenience function to return a ParserSuccess */
function dist_types_success(result, rest) {
    return { success: true, result, rest };
}
/** Convenience function to return a CaptureParserSuccess */
function types_captureSuccess(result, rest, captures) {
    return { success: true, result, rest, captures };
}
/** Convenience function to return a ParserFailure */
function dist_types_failure(message, rest) {
    return { success: false, message, rest };
}
/** Convenience function to create a ParserNode. */
function types_createNode(parent, parser) {
    return {
        parent,
        parser,
        child: null,
        closed: false,
    };
}
/** Convenience function where, given an array of parsers, it creates a tree we can use for backtracking.
 * This tree is what `seq` use. It's used to keep track of the parsers we've tried so far,
 * so we can backtrack if we need to.
 */
function types_createTree(parsers) {
    if (parsers.length === 0) {
        return null;
    }
    const rootNode = types_createNode(null, parsers[0]);
    let currentNode = rootNode;
    for (let i = 1; i < parsers.length; i++) {
        currentNode.child = types_createNode(currentNode, parsers[i]);
        currentNode = currentNode.child;
    }
    return rootNode;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/tarsec@0.0.18/node_modules/tarsec/dist/combinators.js




/**
 * Takes a parser and runs it zero or more times, returning the results as an array.
 * If the parser is a capture parser, it returns the captures as an array in this form:
 *
 * ```ts
 * { captures: <array of captures> }
 * ```
 *
 * @param parser - parser to run
 * @returns - parser that runs the given parser zero to many times,
 * and returns the result as an array
 */
function combinators_many(parser) {
    return dist_trace_trace("many", (input) => {
        let results = [];
        let captures = [];
        let rest = input;
        while (true) {
            let parsed = parser(rest);
            if (!parsed.success) {
                if (Object.keys(captures).length) {
                    return types_captureSuccess(results, rest, { captures });
                }
                else {
                    return dist_types_success(results, rest);
                }
            }
            results.push(parsed.result);
            if (types_isCaptureResult(parsed)) {
                captures.push(parsed.captures);
            }
            rest = parsed.rest;
            // don't loop infinitely on empty strings
            if (rest === "") {
                if (Object.keys(captures).length) {
                    return types_captureSuccess(results, rest, { captures });
                }
                else {
                    return dist_types_success(results, rest);
                }
            }
        }
    });
}
/**
 * Same as `many`, but fails if the parser doesn't match at least once.
 *
 * @param parser - parser to run
 * @returns a parser that runs the given parser one to many times,
 */
function combinators_many1(parser) {
    return dist_trace_trace(`many1`, (input) => {
        let result = combinators_many(parser)(input);
        // this logic doesn't work with optional and not
        if (result.rest !== input) {
            return result;
        }
        return {
            success: false,
            rest: input,
            message: "expected at least one match",
        };
    });
}
/**
 * Takes a parser, runs it, and returns the number of times it succeeded.
 * @param parser - parser to run
 * @returns - the number of times the parser succeeded.
 */
function combinators_count(parser) {
    return trace("count", (input) => {
        const result = combinators_many(parser)(input);
        if (result.success) {
            if (result.result.length === 0) {
                return failure("expected at least one match", input);
            }
            return success(result.result.length, result.rest);
        }
        return result;
    });
}
/**
 * Takes a parser, runs it n times, and returns the results as an array.
 * If it cannot run the parser n times, it fails without consuming input.
 * @param num - number of times to run the parser
 * @param parser - parser to run
 * @returns - parser that runs the given parser `num` times and returns an array of the results
 */
function combinators_exactly(num, parser) {
    return trace("exactly", (input) => {
        let results = [];
        let rest = input;
        for (let i = 0; i < num; i++) {
            let parsed = parser(rest);
            if (!parsed.success) {
                return failure(`expected ${num} matches, got ${i}`, input);
            }
            results.push(parsed.result);
            rest = parsed.rest;
        }
        return success(results, rest);
    });
}
/**
 * Same as `many`, but joins the results into a single string.
 *
 * @param parser - parser to run. The parser must return a string as its result.
 * @returns - parser that runs the given parser zero to many times,
 * and returns the result as a single string
 */
function combinators_manyWithJoin(parser) {
    return dist_trace_trace("manyWithJoin", (input) => {
        const result = combinators_many(parser)(input);
        if (result.success) {
            return Object.assign(Object.assign({}, result), { result: result.result.join("") });
        }
        return result;
    });
}
/**
 * Same as `many1`, but joins the results into a single string.
 *
 * @param parser - parser to run. The parser must return a string as its result.
 * @returns - parser that runs the given parser one to many times,
 * and returns the result as a single string
 */
function combinators_many1WithJoin(parser) {
    return dist_trace_trace("many1WithJoin", (input) => {
        const result = combinators_many1(parser)(input);
        if (result.success) {
            return Object.assign(Object.assign({}, result), { result: result.result.join("") });
        }
        return result;
    });
}
/**
 * `or` takes an array of parsers and runs them sequentially.
 * It returns the results of the first parser that succeeds.
 * You can use `capture` in an `or`:
 *
 * ```ts
 * const parser = or(capture(digit, "num"), capture(word, "name"));
 * ```
 *
 * `or` supports backtracking by returning a `nextParser`:
 *
 * ```ts
 * const parser = or(str("hello"), str("hello!"));
 *
 * // this will match the first parser
 * const result = parser("hello");
 *
 * // but or returns the untried parsers as a new parser
 * result.nextParser("hello!"); // works
 *
 * // result.nextParser is the same as or(str("hello!"))
 * ```
 *
 * @param parsers - parsers to try
 * @returns - a parser that tries each parser in order. Returns the result of the first parser that succeeds.
 */
function combinators_or(...parsers) {
    return dist_trace_trace(`or()`, (input) => {
        for (let i = 0; i < parsers.length; i++) {
            let result = parsers[i](input);
            if (result.success) {
                if (i === parsers.length - 1)
                    return result;
                const nextParser = combinators_or(...parsers.slice(i + 1));
                /* console.log({ nextParser }, parsers.slice(i + 1)); */
                return Object.assign(Object.assign({}, result), { nextParser });
            }
        }
        return dist_types_failure(`all parsers failed`, input);
    });
}
/**
 * Takes a parser and runs it. If the parser fails,
 * optional returns a success with a null result.
 *
 * @param parser - parser to run
 * @returns - a parser that runs the given parser.
 * If it fails, returns a success with a null result.
 */
function combinators_optional(parser) {
    return dist_trace_trace("optional", (input) => {
        let result = parser(input);
        if (result.success) {
            return result;
        }
        return dist_types_success(null, input);
    });
}
/**
 * Takes a parser and runs it. If the parser fails,
 * `not` returns a success with a `null` result.
 * If the parser succeeds, `not` returns a failure.
 *
 * @param parser - parser to run
 * @returns - a parser that runs the given parser.
 * If it fails, returns a success with a `null` result.
 * If it succeeds, returns a failure.
 */
function combinators_not(parser) {
    return trace("not", (input) => {
        let result = parser(input);
        if (result.success) {
            return {
                success: false,
                rest: input,
                message: "expected parser not to succeed",
            };
        }
        return success(null, input);
    });
}
/**
 * Takes three parsers, `open`, `close`, and `parser`.
 * `between` matches something that matches `parser`,
 * surrounded by `open` and `close`. It returns the result of `parser`.
 * If any of the parsers fail, `between` fails.
 *
 * @param open - parser for the opening delimiter
 * @param close - parser for the closing delimiter
 * @param parser - parser for the content
 * @returns a parser that returns the result of `parser`.
 */
function combinators_between(open, close, parser) {
    return (input) => {
        const result1 = open(input);
        if (!result1.success) {
            return result1;
        }
        const parserResult = parser(result1.rest);
        if (!parserResult.success) {
            return parserResult;
        }
        const result2 = close(parserResult.rest);
        if (!result2.success) {
            return result2;
        }
        return dist_types_success(parserResult.result, result2.rest);
    };
}
/**
 * Parses many instances of the parser separated by separator.
 * @param separator
 * @param parser
 * @returns a parser that runs the given parser zero to many times, separated by the separator parser.
 */
function combinators_sepBy(separator, parser) {
    return (input) => {
        let results = [];
        let rest = input;
        while (true) {
            const result = parser(rest);
            if (!result.success) {
                return dist_types_success(results, rest);
            }
            results.push(result.result);
            rest = result.rest;
            const sepResult = separator(rest);
            if (!sepResult.success) {
                return dist_types_success(results, rest);
            }
            rest = sepResult.rest;
        }
    };
}
/**
 * Convenience function to use as the second argument to `seq` to get all the results from `seq`
 * @param results
 * @param captures
 * @returns `results`
 */
function combinators_getResults(results, captures) {
    return results;
}
/**
 * Convenience function to use as the second argument to seq to get all the captures.
 * @param results
 * @param captures
 * @returns `captures`
 */
function combinators_getCaptures(results, captures) {
    return captures;
}
/**
 * `capture` is the only way to create a capture. Given a parser and a name,
 * `capture` runs the parser and saves its result in a captures object
 * with the given name as the key. It returns the result from the parser,
 * and attaches the captures object along with it.
 *
 * @param parser - parser to run
 * @param name - name of the capture
 * @returns - the results of the parser, with the captures object attached.
 */
function combinators_capture(parser, name) {
    return dist_trace_trace(`capture(${dist_utils_escape(name)})`, (input) => {
        let result = parser(input);
        if (result.success) {
            const captures = {
                [name]: result.result,
            };
            return Object.assign(Object.assign({}, result), { captures });
        }
        return result;
    });
}
/**
 * Returns a parser that consumes input till the given parser succeeds.
 * @param parser - the stop parser
 * @returns a parser that consumes the input string until the stop parser succeeds.
 * Then it returns the consumed input as a string.
 * The stop parser's match is not included in the result.
 */
function combinators_manyTill(parser) {
    return (input) => {
        let current = 0;
        while (current < input.length) {
            const parsed = parser(input.slice(current));
            if (parsed.success) {
                return success(input.slice(0, current), input.slice(current));
            }
            current++;
        }
        return success(input, "");
    };
}
/**
 * Just like `manyTill`, but fails unless at least one character of input is consumed.
 * @param parser - the stop parser
 * @returns a parser that consumes the input string until the stop parser succeeds.
 */
function combinators_many1Till(parser) {
    return (input) => {
        let current = 0;
        while (current < input.length) {
            const parsed = parser(input.slice(current));
            if (parsed.success) {
                if (current === 0) {
                    return dist_types_failure("expected to consume at least one character of input", input);
                }
                return dist_types_success(input.slice(0, current), input.slice(current));
            }
            current++;
        }
        if (current === 0) {
            return dist_types_failure("expected to consume at least one character of input", input);
        }
        return dist_types_success(input, "");
    };
}
/**
 * `manyTillOneOf` is an optimized version of `manyTill`.
 * The `manyTill` combinator is slow because it runs the given parser
 * on every character of the string until it succeeds. However, if you
 * just want to consume input until you get to a substring,
 * use `manyTillOneOf`. It uses `indexOf`, which is significantly faster
 * than running a parser over every character.
 *
 * Given an array of strings, this parser consumes input until it hits one of those strings.
 * If none of the strings is found, the parser will consume all input and return success.
 *
 * @param str - the string to stop at
 * @param options - object of optional parameters. { insensitive: boolean }
 * @returns a parser that consumes the input string until one of the given strings is found.
 */
function combinators_manyTillOneOf(stops, { insensitive = false } = {}) {
    return trace(`manyTillOneOf(${escape(stops.join(","))})`, (input) => {
        const indexes = [];
        stops.forEach((stop) => {
            const index = insensitive
                ? input.toLocaleLowerCase().indexOf(stop.toLocaleLowerCase())
                : input.indexOf(stop);
            if (index !== -1) {
                indexes.push(index);
            }
        });
        if (indexes.length === 0) {
            return success(input, "");
        }
        const min = Math.min(...indexes);
        return success(input.slice(0, min), input.slice(min));
    });
}
/**
 * `manyTillStr` is an optimized version of `manyTill`.
 * The `manyTill` combinator is slow because it runs the given parser
 * on every character of the string until it succeeds. However, if you
 * just want to consume input until you get to a substring,
 * use `manyTillStr`. It uses `indexOf`, which is significantly faster
 * than running a parser over every character.
 *
 * @param str - the string to stop at
 * @param options - object of optional parameters. { insensitive: boolean }
 * @returns a parser that consumes the input string until the given string is found.
 */
function combinators_manyTillStr(str, { insensitive = false } = {}) {
    return trace(`manyTillStr(${escape(str)})`, (input) => {
        return combinators_manyTillOneOf([str], { insensitive })(input);
    });
}
/**
 * Like `manyTillStr`, but case insensitive.
 * @param str - the string to stop at
 * @returns a parser that consumes the input string until the given string is found.
 */
function combinators_iManyTillStr(str) {
    return combinators_manyTillStr(str, { insensitive: true });
}
/**
 * `map` is a parser combinator that takes a parser and a mapper function.
 * If the parser succeeds, it maps its result using the mapper function.
 * You can think of map as a general `map`, like for functors, applied to a parser.
 * Since `map` itself is a parser, you can use it in `seq` or other combinators.
 *
 * @param parser - parser to run
 * @param mapperFunc - function to map the result of the parser
 * @returns
 */
function combinators_map(parser, mapperFunc) {
    return dist_trace_trace(`map(${mapperFunc})`, (input) => {
        let parsed = parser(input);
        if (parsed.success) {
            return Object.assign(Object.assign({}, parsed), { result: mapperFunc(parsed.result) });
        }
        return parsed;
    });
}
/**
 * Given a parser that returns a string, `search` looks for all substrings in a string that match that parser.
 * For example, given a parser that matches quoted strings, `search` will return an array of all the quoted strings
 * it finds in the input, as an array.
 *
 * The rest of the input that isn't part of the result is simply joined together and returned as a string.
 * If you need a more structured result + rest, you can use `within` instead.
 *
 * @param parser - a parser that returns a string
 * @returns - a parser that returns an array of strings
 */
function combinators_search(parser) {
    return trace("search", (input) => {
        let parsed = within(parser)(input);
        if (parsed.success) {
            const result = parsed.result
                .filter((x) => x.type === "matched")
                .map((x) => x.value);
            const rest = parsed.result
                .filter((x) => x.type === "unmatched")
                .map((x) => x.value)
                .join(" ");
            return success(result, rest);
        }
        return success("", input);
    });
}
/*
To add backtracking support requires a fairly big change. Here's an example that needs backtracking.

```ts
  const parser = seq([
        str("hello "),
        or(str("world"), str("world!")),
        optional("?")
    ], getResults);
```

If we try to parse `"hello world!"`, the first parser in the OR will succeed, but then we'll get stuck at the `optional`. Instead, we need to go back up the tree and try the second parser in the OR. A few things need to happen.

1. instead of just processing these parsers sequentially in a for loop, we need to model them as a tree
2. the OR parser needs to let us know that there are other branches to try.

For #2, there's an optional `nextParser` key on a parser success. The or parser can use this to say "a parser succeeded and here's the result, but there are other parsers that could be tried". `nextParser` is a parser that runs the remaining branches. So in this example, the OR would return a success with `nextParser = or(str("world"))`.

Next, we need to model this as a tree. Each node in the tree has a parent and child and the parser for that node.

```ts
  parent: Node;
  parser: GeneralParser<any, any> | null;
  child: Node;
```

Hopefully that is self-explanatory. We start at the root of the tree, try the parser there, then use `.child` to go to the next node and so on. We don't model multiple paths as multiple children. To keep the code simple, we do something else.

Each node also has a `closed` key. Once we've run the parser for a node, we mark it `closed`. Closed means there are no more branches here. UNLESS, the parser returns a `nextParser`. In that case, we *don't* mark it closed because there are still other options to try. In that case, we also *replace* the parser on that node with nextParser.

So, going back to the hello world example, let's say we're stuck at the `optional`:

```ts
  const parser = seq([
        str("hello "),
        or(str("world"), str("world!")),
        optional("?")
    ], getResults);
```

We use `.parent` to go back up the tree. We're looking for a node that isn't closed. If we find one, we start again from there. In this case, we'd find an open node at the or with parser `or(str("world"))`. We can restart from there, but there's a bunch of state to reset.

1. From the new `or` parser, we need to go to the optional parser. We're doing it all again in the same order. This is one reason why it's easier to model this without multiple children. Otherwise, all the children would have to point to the next level, the next level would have to point to all the children in the previous level, and you'd have multiple parents, which is awful to deal with.

2. We have consumed input and added to the results. We need to undo that. At this point, the input is `!`, because we've consumed `hello world`. And the results array is `["hello ", "world"]`. We need to rewind both of those.

To do that, I count how many levels up we've gone to find another branch, and just pop that many elements off the results array. So results is now `["hello "]`. The input is trickier. How would I keep track of what the input was when we were at the OR the last time?

This is where the final key on a tree node comes in. Nodes also have an optional `input` key.

IF a parser succeeds, and
IF there's a nextParser,
We know we may come back to this node. So we save the current input as `.input` on the node.

This approach has some issues. Notably, it doesn't work if you need to backtrack at multiple points in the tree. The test `backtracking-deep.test.ts` shows this.

The code is also complex and it would be easy to have bugs in this logic. I wish there was a cleaner solution for rewinding state.
*/
/**
 * seq takes an array of parsers and runs them sequentially.
 * If any of the parsers fail, seq fails without consuming any input.
 *
 * The second argument to seq is a function.
 * The first argument of that function is an array of results:
 * one result from each of the parsers you gave to seq.
 * The second is an object containing any captures.
 * You can use this second argument, the transformer function,
 * to transform these however you want and return a result
 *
 * Tarsec includes the utility functions `getResults` and `getCaptures`
 * to just return the results array or captures object respectively for you.
 *
 * Finally, you don't need to use seq at all. You can just hand write the logic.
 * But you'll need to do the error handling
 * and pass the remaining input to the next parser yourself.
 * seq also does some backtracking for you that you will need to do yourself.
 *
 * Also see `seqR` and `seqC` for convenience functions that return the results or captures respectively.
 *
 * @param parsers - parsers to run sequentially
 * @param transform - function to transform the results and captures. The params are the results and captures
 * @param debugName - optional name for trace debugging
 * @returns
 */
function combinators_seq(parsers, transform, debugName = "") {
    return dist_trace_trace(`seq(${debugName})`, (input) => {
        const results = [];
        let rest = input;
        const captures = {};
        const rootNode = types_createTree(parsers);
        let current = rootNode;
        while (current) {
            const parser = current.parser;
            if (!parser) {
                console.log({ current, parser, results, captures });
                throw new Error("parser is null");
            }
            const parsed = parser(rest);
            current.closed = true;
            /*       console.log({ parsed }); */
            if (!parsed.success) {
                const [ancestor, count] = utils_findAncestorWithNextParser(current);
                if (ancestor) {
                    current = ancestor;
                    rest = ancestor.input;
                    utils_popMany(results, count);
                    continue;
                }
                else {
                    // don't consume input if we're failing
                    return Object.assign(Object.assign({}, parsed), { rest: input });
                }
            }
            results.push(parsed.result);
            if (parsed.nextParser) {
                /* console.log("setting next parser", parsed.nextParser); */
                current.parser = parsed.nextParser;
                current.input = rest;
                current.closed = false;
            }
            rest = parsed.rest;
            if (types_isCaptureResult(parsed)) {
                for (const key in parsed.captures) {
                    captures[key] = parsed.captures[key];
                }
            }
            current = current.child;
        }
        const result = transform(results, captures);
        return dist_types_success(result, rest);
    });
}
/** Just like seq except it returns the results.
 * It's like using `seq([parsers], getResults)`.
 */
function combinators_seqR(...parsers) {
    return combinators_seq(parsers, combinators_getResults);
}
/** Just like seq except it returns the captures.
 * It's like using `seq([parsers], getCaptures)`.
 */
function combinators_seqC(...parsers) {
    return combinators_seq(parsers, combinators_getCaptures);
}
/**
 * Match takes an input string and a parser. If the parser matches the input string
 * and consumes the entire input string, `match` returns `true`. Otherwise it returns `false`.
 *
 * @param input - input string
 * @param parser - parser to match input against
 * @returns - true if the parser matches the input and consumes all input, false otherwise
 */
function combinators_match(input, parser) {
    const result = parser(input);
    return result.success && result.rest === "";
}
function combinators_ifElse(condition, ifParser, elseParser) {
    return trace(`ifElse(${escape(condition)})`, (input) => {
        if (condition) {
            return ifParser(input);
        }
        return elseParser(input);
    });
}
/**
 * Apply multiple parsers to the same input and collect all the results.
 * Consumes no input.
 *
 * @param parsers - parsers to try
 * @returns
 */
function combinators_manyParsers(...parsers) {
    return trace(`manyParsers()`, (input) => {
        const results = [];
        for (let i = 0; i < parsers.length; i++) {
            let result = parsers[i](input);
            results.push(result);
        }
        if (results.some(isSuccess)) {
            return success(results, input);
        }
        return failure("no parsers succeeded", input);
    });
}
/**
 * Runs all the given parsers. If they all succeed, returns their results as an array.
 * Otherwise fails. Consumes no input.
 * @param parsers - parsers to try
 * @returns - An array of results, or a failure.
 */
function combinators_and(...parsers) {
    return trace(`and()`, (input) => {
        const results = combinators_manyParsers(...parsers)(input);
        if (results.success) {
            const successes = results.result.filter(isSuccess);
            if (successes.length === results.result.length) {
                return success(results.result.map((r) => r.result), input);
            }
            return failure("not all parsers succeeded", input);
        }
        return results;
    });
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/tarsec@0.0.18/node_modules/tarsec/dist/parsers.js





/**
 * Takes a character. Returns a parser that parses that character.
 *
 * @param c - character to parse
 * @returns - parser that parses the given character
 */
function dist_parsers_char(c) {
    return dist_trace_trace(`char(${dist_utils_escape(c)})`, (input) => {
        if (input.length === 0) {
            return {
                success: false,
                rest: input,
                message: "unexpected end of input",
            };
        }
        if (input[0] === c) {
            return dist_types_success(c, input.slice(1));
        }
        return dist_types_failure(`expected ${dist_utils_escape(c)}, got ${dist_utils_escape(input[0])}`, input);
    });
}
/**
 * Takes a string. Returns a parser that parses that string.
 *
 * @param s - string to match on
 * @returns - parser that parses the given string
 */
function parsers_str(s) {
    return dist_trace_trace(`str(${dist_utils_escape(s)})`, (input) => {
        if (input.substring(0, s.length) === s) {
            return dist_types_success(s, input.slice(s.length));
        }
        return dist_types_failure(`expected ${s}, got ${input.substring(0, s.length)}`, input);
    });
}
/**
 * Like `str`, but case insensitive.
 * @param s - string to match on, case insensitive
 * @returns - parser that matches the given string, case insensitive
 */
function parsers_istr(s) {
    return trace(`istr(${escape(s)})`, (input) => {
        if (input.substring(0, s.length).toLocaleLowerCase() === s.toLocaleLowerCase()) {
            return success(input.substring(0, s.length), input.slice(s.length));
        }
        return failure(`expected ${s}, got ${input.substring(0, s.length)}`, input);
    });
}
/**
 * Takes a string. Returns a parser that parses
 * one of the characters in that string.
 *
 * @param chars - string of possible characters
 * @returns - parser that parses one of the given characters
 */
function parsers_oneOf(chars) {
    return dist_trace_trace(`oneOf(${dist_utils_escape(chars)})`, (input) => {
        if (input.length === 0) {
            return dist_types_failure("unexpected end of input", input);
        }
        const c = input[0];
        if (chars.includes(c)) {
            return dist_parsers_char(c)(input);
        }
        return dist_types_failure(`expected one of ${dist_utils_escape(chars)}, got ${c}`, input);
    });
}
/**
 * Takes a string. Returns a parser that parses one character
 * that's not any of the characters in the given string
 *
 * @param chars - string of characters to avoid
 * @returns - parser that parses a character that is not in the given string
 */
function parsers_noneOf(chars) {
    return dist_trace_trace(`noneOf(${dist_utils_escape(chars)})`, (input) => {
        if (input.length === 0) {
            return dist_types_failure("unexpected end of input", input);
        }
        if (chars.includes(input[0])) {
            return dist_types_failure(`expected none of ${dist_utils_escape(chars)}, got ${input[0]}`, input);
        }
        return dist_parsers_char(input[0])(input);
    });
}
/**
 * A parser that parses any one character.
 * Fails on empty strings, succeeds otherwise.
 *
 * @param input - input string
 * @returns - ParserResult
 */
const parsers_anyChar = dist_trace_trace("anyChar", (input) => {
    if (input.length === 0) {
        return dist_types_failure("unexpected end of input", input);
    }
    return dist_types_success(input[0], input.slice(1));
});
/** A parser that matches one of " \t\n\r". */
const parsers_space = parsers_oneOf(" \t\n\r");
/** A parser that matches one or more spaces. */
const parsers_spaces = combinators_many1WithJoin(parsers_space);
/** A parser that matches one digit. */
const parsers_digit = parsers_oneOf("0123456789");
/** A parser that matches one letter, case insensitive. */
const parsers_letter = parsers_oneOf("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
/** A parser that matches one digit or letter, case insensitive. */
const parsers_alphanum = parsers_oneOf("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
/** A parser that matches one word, case insensitive. */
const parsers_word = parsers_regexParser("^[a-z]+", "ui");
/** A parser that matches one or more digits. */
const parsers_num = parsers_regexParser("^[0-9]+");
/** A parser that matches one single or double quote. */
const parsers_quote = parsers_oneOf(`'"`);
/** A parser that matches one tab character. */
const parsers_tab = dist_parsers_char("\t");
/** A parser that matches one newline ("\n" only) character. */
const parsers_newline = dist_parsers_char("\n");
/** A parser that succeeds on an empty string. Returns `null` as the result. */
const parsers_eof = (input) => {
    if (input === "") {
        return success(null, input);
    }
    return failure("expected end of input", input);
};
/** A parser that matches a quoted string, in single or double quotes.
 * Returns the string as the result, including the quotes.
 */
const parsers_quotedString = combinators_seq([parsers_quote, combinators_manyWithJoin(parsers_noneOf(`"'`)), parsers_quote], (results) => results.join(""));
/**
 * Returns a parser that matches a regex. If you pass in a string,
 * it will get converted to a regex. The regex should always match from the start of the input.
 * If you pass in a string, a `^` will get prepended to it.
 *
 * @param str - regex string or RegExp instance to match
 * @param options - regex options (i = ignore case, g = global, m = multiline, u = unicode)
 * @returns - parser that matches the given regex
 */
function parsers_regexParser(str, options = "") {
    let re;
    if (typeof str === "string") {
        re = new RegExp(str.startsWith("^") ? str : `^${str}`, options);
    }
    else {
        re = str;
    }
    return dist_trace_trace(`regex(${str})`, (input) => {
        const match = input.match(re);
        if (match) {
            return dist_types_success(match[0], input.slice(match[0].length));
        }
        return dist_types_failure(`expected ${str}, got ${input.slice(0, 10)}`, input);
    });
}
/**
 * Like `regexParser`, but you can name your capture groups
 * and get them back as the result instead.
 * Fails if it doesn't have the same number of names as capture groups.
 *
 * @param str - regex string or RegExp instance to match
 * @param options - string of regex options (i = ignore case, g = global, m = multiline, u = unicode)
 * @param captureNames - names of the captures
 * @returns - parser that matches the given regex
 */
function parsers_captureRegex(str, options = "", ...captureNames) {
    let re;
    if (typeof str === "string") {
        re = new RegExp(str.startsWith("^") ? str : `^${str}`, options);
    }
    else {
        re = str;
    }
    return trace(`captureRegex(${str})`, (input) => {
        const match = input.match(re);
        if (match) {
            if (match.slice(1).length > captureNames.length) {
                return failure(`more capture groups than names. ${match.slice(1).length} capture groups, ${captureNames.length} names`, input);
            }
            if (match.slice(1).length < captureNames.length) {
                return failure(`fewer capture groups than names. ${match.slice(1).length} capture groups, ${captureNames.length} names`, input);
            }
            const captures = Object.assign({}, Object.fromEntries(match.slice(1).map((value, index) => [captureNames[index], value])));
            return success(captures, input.slice(match[0].length));
        }
        return failure(`expected ${str}, got ${input.slice(0, 10)}`, input);
    });
}
/**
 * Return a parser that takes a key and a value.
 * The parser consumes no input and always succeeds,
 * and returns `null` as the result. It also returns a captures object
 * with that key-value pair set. This is useful when you need to inject
 * a key-value pair into captures for a `seq`.
 *
 * For example, here is a Markdown heading parser.

 * ```ts
 * export const headingParser: Parser<Heading> = seqC(
 *   capture(count(char("#")), "level"),
 *   spaces,
 *   capture(many1Till(or(char("\n"), eof)), "content")
 * );
```
 *
 * This parser returns
 *
 * ```ts
 * {
 *   level: number,
 *   content: string
 * }
 * ```
 * but the type of heading is actually
 *
 * ```ts
 * type Heading = {
 *   type: "heading";
 *   level: number;
 *   content: string;
 * };
 * ```
 *
 * The `type` key is missing. You can use `set` to inject the `type`
 * key-value pair into captures:
 *
 * ```ts
 * export const headingParser: Parser<Heading> = seqC(
 *   set("type", "heading"),
 *   capture(count(char("#")), "level"),
 *   spaces,
 *   capture(many1Till(or(char("\n"), eof)), "content")
 * );
 * ```
 *
 * @param key - key to set on captures object
 * @param value - value to set on captures object
 * @returns
 */
function parsers_set(key, value) {
    return dist_trace_trace(`set(${key}, ${value})`, (input) => {
        return types_captureSuccess(null, input, { [key]: value });
    });
}
/**
 * A parser that always succeeds with the given value.
 * @param value - value to succeed with
 * @returns value
 */
function parsers_succeed(value) {
    return trace(`succeed(${value})`, (input) => {
        return success(value, input);
    });
}
/**
 * A parser that always fails with the given message.
 * @param message - message to fail with
 * @returns failure
 */
function parsers_fail(message) {
    return trace(`fail(${message})`, (input) => {
        return failure(message, input);
    });
}
/**
 * Takes a string. Succeeds if the given input contains that string.
 * Consumes no input.
 *
 * @param substr - substring to find
 * @returns - parser that succeeds if the given input contains that string
 */
function parsers_includes(substr) {
    return trace(`includes(${substr})`, (input) => {
        if (input.includes(substr)) {
            return success(substr, input);
        }
        return failure(`expected ${escape(input)} to include ${escape(substr)}`, input);
    });
}
/**
 * Like `includes`, but case-insensitive.
 *
 * @param substr - substring to find
 * @returns - parser that succeeds if the given input contains that string
 */
function parsers_iIncludes(substr) {
    return trace(`iIncludes(${substr})`, (input) => {
        if (input.toLowerCase().includes(substr.toLowerCase())) {
            return success(substr, input);
        }
        return failure(`expected "${input}" to include "${substr}" (case-insensitive)`, input);
    });
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/tarsec@0.0.18/node_modules/tarsec/dist/index.js





;// CONCATENATED MODULE: ./node_modules/.pnpm/typestache@0.4.4/node_modules/typestache/dist/lib/mustacheParser.js

const _tagName = combinators_sepBy(dist_parsers_char("."), parsers_regexParser("([\\[\\]a-zA-Z0-9_]+)"));
const tagName = (input) => {
    const result = _tagName(input);
    if (result.success && result.result.length > 0) {
        return result;
    }
    else {
        return dist_types_failure("must have at least one tag name", input);
    }
};
const optionalType = combinators_seq([combinators_optional(parsers_spaces), combinators_optional(combinators_capture(parsers_str("?"), "optional"))], (r, c) => {
    return {
        optional: !!c.optional,
    };
});
const _varType = combinators_seq([
    combinators_optional(parsers_spaces),
    combinators_optional(combinators_capture(parsers_str("?"), "optional")),
    combinators_optional(parsers_spaces),
    parsers_str(":"),
    combinators_optional(parsers_spaces),
    combinators_capture(combinators_sepBy(combinators_or(parsers_str(" | "), dist_parsers_char("|")), parsers_regexParser("([a-zA-Z0-9_]+)")), "name"),
], (r, c) => {
    return {
        name: c.name,
        optional: !!c.optional,
    };
});
const varType = combinators_or(_varType, optionalType);
const captureWithScope = (captures) => {
    if (captures.name[0] === "this") {
        return {
            ...captures,
            scope: "local",
            name: captures.name.slice(1),
        };
    }
    else if (captures.name[0] === "global") {
        return {
            ...captures,
            scope: "global",
            name: captures.name.slice(1),
        };
    }
    return {
        ...captures,
        scope: "global",
    };
};
const captureSectionWithScope = (captures) => {
    if (captures.name[0] === "this") {
        return {
            ...captures,
            scope: "local",
            name: captures.name.slice(1),
        };
    }
    else if (captures.name[0] === "global") {
        return {
            ...captures,
            scope: "global",
            name: captures.name.slice(1),
        };
    }
    return {
        ...captures,
        scope: "global",
    };
};
const openingTag = (open, close) => combinators_seqC(parsers_str(open), combinators_optional(parsers_spaces), combinators_capture(tagName, "name"), combinators_optional(combinators_capture(varType, "varType")), combinators_optional(parsers_spaces), parsers_str(close));
function mustacheParser_captureCaptures(parser) {
    return dist_trace_trace(`captureCaptures()`, (input) => {
        let result = parser(input);
        if (result.success) {
            return {
                ...result,
                captures: result.result,
            };
        }
        return result;
    });
}
const doubleVariableTag = combinators_seqC(parsers_set("type", "variable"), parsers_set("scope", "global"), mustacheParser_captureCaptures(openingTag("{{", "}}")), parsers_set("triple", false));
const tripleVariableTag = combinators_seqC(parsers_set("type", "variable"), parsers_set("scope", "global"), mustacheParser_captureCaptures(openingTag("{{{", "}}}")), parsers_set("triple", true));
const ampersandVariableTag = combinators_seqC(parsers_set("type", "variable"), parsers_set("scope", "global"), parsers_str("{{"), combinators_optional(parsers_spaces), dist_parsers_char("&"), combinators_optional(parsers_spaces), combinators_capture(tagName, "name"), combinators_optional(combinators_capture(varType, "varType")), combinators_optional(parsers_spaces), parsers_str("}}"), parsers_set("triple", true));
const variableTag = combinators_map(combinators_or(tripleVariableTag, ampersandVariableTag, doubleVariableTag), captureWithScope);
const doubleImplicitVariableTag = combinators_seqC(parsers_set("type", "implicit-variable"), parsers_str("{{"), combinators_optional(parsers_spaces), dist_parsers_char("."), combinators_optional(parsers_spaces), parsers_str("}}"), parsers_set("triple", false));
const tripleImplicitVariableTag = combinators_seqC(parsers_set("type", "implicit-variable"), parsers_str("{{{"), combinators_optional(parsers_spaces), dist_parsers_char("."), combinators_optional(parsers_spaces), parsers_str("}}}"), parsers_set("triple", true));
const ampersandImplicitVariableTag = combinators_seqC(parsers_set("type", "implicit-variable"), parsers_str("{{"), combinators_optional(parsers_spaces), dist_parsers_char("&"), combinators_optional(parsers_spaces), dist_parsers_char("."), combinators_optional(parsers_spaces), parsers_str("}}"), parsers_set("triple", true));
const implicitVariableTag = combinators_or(tripleImplicitVariableTag, ampersandImplicitVariableTag, doubleImplicitVariableTag);
const textParser = combinators_seqC(parsers_set("type", "text"), combinators_capture(combinators_many1Till(parsers_str("{{")), "content"));
const commentTag = combinators_seqC(parsers_set("type", "comment"), parsers_str("{{!"), combinators_capture(combinators_many1Till(parsers_str("}}")), "content"), parsers_str("}}"));
const partialTag = combinators_seqC(parsers_set("type", "partial"), combinators_capture(combinators_between(parsers_str("{{>"), parsers_str("}}"), tagName), "name"));
const createMustacheParser = () => combinators_many1(combinators_or(variableTag, sectionTag, invertedTag, commentTag, partialTag, implicitVariableTag, textParser));
const sectionTag = combinators_map(combinators_seqC(parsers_set("type", "section"), mustacheParser_captureCaptures(openingTag("{{#", "}}")), combinators_capture((input) => createMustacheParser()(input), "content"), parsers_str("{{/"), tagName, parsers_str("}}")), captureSectionWithScope);
const invertedTag = combinators_map(combinators_seqC(parsers_set("type", "inverted"), combinators_capture(combinators_between(parsers_str("{{^"), parsers_str("}}"), tagName), "name"), combinators_capture((input) => createMustacheParser()(input), "content"), parsers_str("{{/"), tagName, parsers_str("}}")), captureSectionWithScope);
const mustacheParser = (input) => {
    const result = createMustacheParser()(input);
    if (result.success) {
        if (result.rest.length > 0) {
            return dist_types_failure(`Unexpected characters after parsing mustache template.`, result.rest);
        }
    }
    return result;
};

;// CONCATENATED MODULE: ./node_modules/.pnpm/typestache@0.4.4/node_modules/typestache/dist/lib/apply.js

const applyParsed = (contents, obj) => {
    return _applyParsed(contents, obj, obj);
};
const _applyParsed = (contents, obj, globalObj, currentContext = []) => {
    return contents
        .map((content) => {
        if (content.type === "text") {
            return content.content;
        }
        if (content.type === "variable") {
            if (content.scope === "global") {
                return renderVariable(deepSeek(globalObj, [...content.name], []), !content.triple);
            }
            return renderVariable(deepSeek(obj, [...content.name], [...currentContext]), !content.triple);
        }
        if (content.type === "section") {
            const value = deepSeek(obj, [...content.name], [...currentContext]);
            if (!value) {
                return "";
            }
            else if (Array.isArray(value)) {
                return value
                    .map((item) => _applyParsed(content.content, item, globalObj))
                    .join("");
            }
            else {
                const str = _applyParsed(content.content, value, globalObj);
                return str;
            }
        }
        if (content.type === "inverted") {
            const value = deepSeek(obj, [...content.name], [...currentContext]);
            return value ? "" : _applyParsed(content.content, obj, globalObj);
        }
        if (content.type === "comment") {
            return "";
        }
        if (content.type === "partial") {
            return `{{>${content.name}}}`;
        }
        if (content.type === "implicit-variable") {
            const value = deepSeek(obj, [...currentContext], []);
            return renderVariable(value, !content.triple);
        }
        return "";
    })
        .join("");
};
/*
When we reference a variable, there are cases we need to handle.

The simplest one is when the variable name is a key in the object:

```ts
{
  user: "Adit"
}

{{user}}
```

However, Mustache also allows you to access variables that are nested within objects:

```ts
{
  user: {
    name: "Adit"
  }
}

{{user.name}}

```

When you use a section, that creates a context, and we need to look up the variable name within that context:

```ts
{
  user: {
    name: "Adit"
  }
}

{{#user}}{{name}}{{/user}}

``

Finally, even in the context, you can reference a top level variable:

```ts
{
  user: {
    name: "Adit"
  },
  greeting: "Hello"
}

{{#user}}{{greeting}}{{/user}}
```
*/
/* const deepSeek = (
  obj: TemplateParams,
  name: string[],
  context: string[]
): any => {
  const value = _deepSeek(obj, name);
  if (value !== "") {
    return value;
  }

  if (context.length > 0) {
    return _deepSeek(obj, [...context, ...name]);
  }
  return "";
};
 */
const deepSeek = (obj, _name, context) => {
    const name = [...context, ..._name];
    if (typeof obj === "string" ||
        typeof obj === "boolean" ||
        typeof obj === "number") {
        if (name.length === 0) {
            return obj;
        }
        else {
            return "";
        }
    }
    let current = obj;
    for (const key of name) {
        if (current[key] === undefined) {
            return "";
        }
        current = current[key];
    }
    return current;
};
const escapedCharacters = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&apos;",
};
const escapeHTML = (_str) => {
    let str = _str;
    for (const [key, value] of Object.entries(escapedCharacters)) {
        str = str.replaceAll(key, value);
    }
    return str;
};
const renderVariable = (variable, escape) => {
    if (variable === undefined || variable === null) {
        return "";
    }
    let str = variable;
    if (typeof variable === "number") {
        str = variable.toString();
    }
    else if (typeof variable === "boolean") {
        str = variable ? "true" : "false";
    }
    if (escape) {
        return escapeHTML(str);
    }
    return str;
};
const apply = (str, obj) => {
    const parsed = mustacheParser(str);
    if (parsed.success) {
        return applyParsed(parsed.result, obj);
    }
    return "";
};

;// CONCATENATED MODULE: ./node_modules/.pnpm/typestache@0.4.4/node_modules/typestache/dist/lib/genType.js
const FgYellow = "\x1b[33m";
const FgGreen = "\x1b[32m";
const FgRed = "\x1b[31m";
const FgReset = "\x1b[0m";
const DEBUG = !!process.env.TYPESTACHE_DEBUG;
if (DEBUG) {
    console.log(FgGreen, "TYPESTACHE DEBUG MODE ON", FgReset);
}
const uniq = (arr) => Array.from(new Set(arr));
const arraysEqual = (a, b) => {
    const setA = new Set(a);
    const setB = new Set(b);
    return setA.size === setB.size && setA.intersection(setB).size === setA.size;
};
const genType_debug = (...args) => {
    if (DEBUG) {
        const rest = args.slice(1);
        const json = rest.map((arg) => {
            if (typeof arg === "object") {
                return JSON.stringify(arg, null, 2);
            }
            return arg;
        });
        console.log(FgYellow, args[0], FgReset, ...json);
    }
};
function hasScope(mustache) {
    return (mustache.type === "section" ||
        mustache.type === "inverted" ||
        mustache.type === "variable");
}
class Generated {
    value;
    constructor(value) {
        this.value = value;
    }
    setValue(value) {
        this.value = value;
    }
    equals(value) {
        if (this.value.type !== value.type) {
            return false;
        }
        if (this.value.type === "default") {
            return this.value.optional === value.optional;
        }
        if (this.value.type === "object") {
            const keys = Object.keys(this.value.internalVal);
            // @ts-ignore
            const otherKeys = Object.keys(value.internalVal);
            if (!arraysEqual(keys, otherKeys)) {
                return false;
            }
            for (const key of keys) {
                // @ts-ignore
                if (!this.value.internalVal[key].equals(value.internalVal[key].value)) {
                    return false;
                }
            }
        }
        else if (this.value.type === "union") {
            return arraysEqual(this.value.internalVal, 
            // @ts-ignore
            value.internalVal);
        }
        return true;
    }
    merge(value) {
        genType_debug("MERGE", "this.value:", this.value, { value });
        if (value.type === "default") {
            return;
        }
        if (this.value.type === "default") {
            this.value = value;
        }
        else if (this.value.type === "object" && value.type === "object") {
            this.value.internalVal = {
                ...this.value.internalVal,
                ...value.internalVal,
            };
        }
        else if (this.equals(value)) {
            // same type and same value, do nothing
        }
        else {
            throw new Error(`Cannot merge ${this.value.type} with ${value.type}: Tried to merge ${JSON.stringify(this.value, null, 2)} with ${JSON.stringify(value, null, 2)}`);
        }
    }
    buildNestedObject(path, value) {
        if (path.length === 0) {
            return value;
        }
        const key = path[0];
        const nestedValue = this.buildNestedObject(path.slice(1), value);
        return {
            type: "object",
            internalVal: {
                [key]: new Generated(nestedValue),
            },
            optional: false,
        };
    }
    setPath(path, value) {
        genType_debug("SET PATH", { path, value });
        if (this.value.type !== "object") {
            throw new Error(`Cannot set path on non-object type. path: ${JSON.stringify(path)}, value: ${JSON.stringify(value, null, 2)}, this.value: ${JSON.stringify(this.value, null, 2)}`);
        }
        if (path.length === 0) {
            return;
        }
        else if (path.length === 1) {
            const key = path[0];
            if (this.value.internalVal[key]) {
                this.value.internalVal[key].merge(value);
            }
            else {
                this.value.internalVal[key] = new Generated(value);
            }
        }
        else {
            const key = path[0];
            if (this.value.internalVal[key]) {
                this.value.internalVal[key].setPath(path.slice(1), value);
            }
            else {
                const nestedValue = this.buildNestedObject(path.slice(1), value);
                this.value.internalVal[key] = new Generated(nestedValue);
            }
        }
    }
    isOptional() {
        if (this.value.type === "object") {
            return this.value.optional;
        }
        else if (this.value.type === "union") {
            return this.value.optional;
        }
        else if (this.value.type === "default") {
            return this.value.optional;
        }
        throw new Error(`Cannot check optional on ${this.value}`);
    }
    walk(parsed, scopeNames = []) {
        genType_debug("WALK", { scopeNames });
        parsed.forEach((mustache) => {
            // @ts-ignore
            genType_debug("\t->", mustache.type, mustache.name || "");
            switch (mustache.type) {
                case "variable":
                    return this.setVariable(mustache, scopeNames);
                case "section":
                    return this.setSection(mustache, scopeNames);
                case "inverted":
                    return this.setInverted(mustache, scopeNames);
                    return;
                default:
                    break;
            }
        });
        return this;
    }
    setVariable(mustache, scopeNames = []) {
        genType_debug("SET VARIABLE", { mustache, scopeNames });
        const hasExplicitType = mustache.varType?.name && mustache.varType.name.length > 0;
        let value;
        if (hasExplicitType) {
            value = {
                type: "union",
                internalVal: mustache.varType.name || [],
                optional: mustache.varType.optional,
            };
        }
        else {
            value = {
                type: "default",
                optional: mustache.varType?.optional || false,
            };
        }
        let fullName = mustache.name;
        if (mustache.scope === "local") {
            fullName = [...scopeNames, ...mustache.name];
        }
        this.setPath(fullName, value);
    }
    setSection(mustache, scopeNames = []) {
        genType_debug("SET SECTION", { name: mustache.name, scopeNames });
        let fullName = mustache.name;
        if (mustache.scope === "local") {
            fullName = [...scopeNames, ...mustache.name];
        }
        const localVars = mustache.content.filter((c) => hasScope(c) && c.scope === "local");
        // no local vars, therefore boolean
        if (localVars.length === 0) {
            this.setPath(fullName, {
                type: "union",
                internalVal: mustache.varType?.name || ["boolean"],
                optional: mustache.varType?.optional || false,
            });
        }
        else {
            this.setPath(fullName, {
                type: "object",
                internalVal: {},
                optional: mustache.varType?.optional || false,
            });
        }
        // NOTE: since we don't support going up the full scope chain,
        // we assume that all variables in the section that are local,
        // are local to this section.
        //
        // Which is why we don't do it this way:
        //this.walk(mustache.content, [...scopeNames, ...mustache.name]);
        if (mustache.scope === "local") {
            this.walk(mustache.content, [...scopeNames, ...mustache.name]);
        }
        else {
            this.walk(mustache.content, mustache.name);
        }
    }
    setInverted(mustache, scopeNames = []) {
        genType_debug("SET INVERTED", { name: mustache.name, scopeNames });
        let fullName = mustache.name;
        if (mustache.scope === "local") {
            fullName = [...scopeNames, ...mustache.name];
        }
        this.setPath(fullName, {
            type: "union",
            internalVal: ["boolean"],
            optional: false,
        });
        this.walk(mustache.content, scopeNames);
    }
    renderValue = (value) => {
        return uniq(value).join(" | ");
    };
    render(level = 1) {
        if (this.value.type === "object") {
            const lines = Object.entries(this.value.internalVal).map(([key, value]) => {
                let _key = key;
                let arrayStr = "";
                const optStr = value.isOptional() ? "?" : "";
                if (key.endsWith("[]")) {
                    _key = key.replace("[]", "");
                    arrayStr = "[]";
                }
                return `${"  ".repeat(level)}${key}${optStr}: ${value.render(level + 1)}${arrayStr};\n`;
            });
            return `{\n${lines.join("")}${"  ".repeat(level - 1)}}`;
        }
        else if (this.value.type === "union") {
            return this.renderValue(this.value.internalVal);
        }
        else if (this.value.type === "default") {
            return this.renderValue(["string", "boolean", "number"]);
        }
        throw new Error(`Cannot render ${JSON.stringify(this.value, null, 2)}`);
    }
}
const render = (generated, level = 1) => {
    return generated.render(level);
};
const genType = (parsed) => {
    const generated = new Generated({
        type: "object",
        internalVal: {},
        optional: false,
    });
    generated.walk(parsed);
    return render(generated);
};

;// CONCATENATED MODULE: ./node_modules/.pnpm/typestache@0.4.4/node_modules/typestache/dist/lib/index.js





;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/templates/backends/typescriptGenerator/imports.js
// THIS FILE WAS AUTO-GENERATED
// Source: lib/templates/backends/typescriptGenerator/imports.mustache
// Any manual changes will be lost.

const template = `import OpenAI from "openai";
import { zodResponseFormat } from "openai/helpers/zod";
import { z } from "zod";
import * as readline from "readline";
import fs from "fs";
import { StatelogClient } from "statelog-client";
import { nanoid } from "nanoid";

const statelogHost = "http://localhost:1065";
const traceId = nanoid();
const statelogClient = new StatelogClient({host: statelogHost, tid: traceId});

const model = "gpt-5-nano-2025-08-07";

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});`;
const imports_render = (args) => {
    return apply(template, args);
};
/* harmony default export */ const imports = (imports_render);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/templates/backends/typescriptGenerator/promptFunction.js
// THIS FILE WAS AUTO-GENERATED
// Source: lib/templates/backends/typescriptGenerator/promptFunction.mustache
// Any manual changes will be lost.

const promptFunction_template = `
async function _{{{variableName:string}}}({{{argsStr:string}}}): Promise<{{{typeString:string}}}> {
  const prompt = {{{promptCode:string}}};
  const startTime = performance.now();
  const messages:any[] = [{ role: "user", content: prompt }];
  const tools = {{{tools}}};

  let completion = await openai.chat.completions.create({
    model,
    messages,
    tools,
    response_format: zodResponseFormat(z.object({
      value: {{{zodSchema:string}}}
    }), "{{{variableName:string}}}_response"),
  });
  const endTime = performance.now();
  statelogClient.promptCompletion({
    messages,
    completion,
    model,
    timeTaken: endTime - startTime,
  });

  let responseMessage = completion.choices[0].message;
  // Handle function calls
  while (responseMessage.tool_calls && responseMessage.tool_calls.length > 0) {
    // Add assistant's response with tool calls to message history
    messages.push(responseMessage);
    let toolCallStartTime, toolCallEndTime;

    // Process each tool call
    for (const toolCall of responseMessage.tool_calls) {
      {{{functionCalls:string}}}
    }

    const nextStartTime = performance.now();
    // Get the next response from the model
    completion = await openai.chat.completions.create({
      model,
      messages: messages,
      tools: tools,
    });
    const nextEndTime = performance.now();

    statelogClient.promptCompletion({
      messages,
      completion,
      model,
      timeTaken: nextEndTime - nextStartTime,
    });

    responseMessage = completion.choices[0].message;
  }

  // Add final assistant response to history
  messages.push(responseMessage);

  try {
  const result = JSON.parse(completion.choices[0].message.content || "");
  return result.value;
  } catch (e) {
    return completion.choices[0].message.content;
    // console.error("Error parsing response for variable '{{{variableName:string}}}':", e);
    // console.error("Full completion response:", JSON.stringify(completion, null, 2));
    // throw e;
  }
}
`;
const promptFunction_render = (args) => {
    return apply(promptFunction_template, args);
};
/* harmony default export */ const promptFunction = (promptFunction_render);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/templates/backends/typescriptGenerator/tool.js
// THIS FILE WAS AUTO-GENERATED
// Source: lib/templates/backends/typescriptGenerator/tool.mustache
// Any manual changes will be lost.

const tool_template = `const {{{name:string}}}Tool: OpenAI.Chat.Completions.ChatCompletionTool = {
    type: "function",
    function: {
      name: "{{{name:string}}}",
      description:
        "{{{description:string}}}",
      parameters: {
        type: "object",
        properties: {{{properties:string}}},
        required: [{{{requiredParameters:string}}}],
        additionalProperties: false,
      },
    },
  };
`;
const tool_render = (args) => {
    return apply(tool_template, args);
};
/* harmony default export */ const tool = (tool_render);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/templates/backends/typescriptGenerator/toolCall.js
// THIS FILE WAS AUTO-GENERATED
// Source: lib/templates/backends/typescriptGenerator/toolCall.mustache
// Any manual changes will be lost.

const toolCall_template = `if (toolCall.type === "function" &&
  toolCall.function.name === "{{{name:string}}}"
) {
  const args = JSON.parse(toolCall.function.arguments);

  toolCallStartTime = performance.now();
  const result = await {{{name}}}(args);
  toolCallEndTime = performance.now();

  console.log("Tool '{{{name:string}}}' called with arguments:", args);
  console.log("Tool '{{{name:string}}}' returned result:", result);

statelogClient.toolCall({
    toolName: "{{{name:string}}}",
    args,
    output: result,
    model,
    timeTaken: toolCallEndTime - toolCallStartTime,
  });

  // Add function result to messages
  messages.push({
    role: "tool",
    tool_call_id: toolCall.id,
    content: JSON.stringify(result),
  });
}`;
const toolCall_render = (args) => {
    return apply(toolCall_template, args);
};
/* harmony default export */ const toolCall = (toolCall_render);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/templates/backends/typescriptGenerator/functionDefinition.js
// THIS FILE WAS AUTO-GENERATED
// Source: lib/templates/backends/typescriptGenerator/functionDefinition.mustache
// Any manual changes will be lost.

const functionDefinition_template = `async function {{{functionName:string}}}({{{args}}}) {
    {{{functionBody}}}
}`;
const functionDefinition_render = (args) => {
    return apply(functionDefinition_template, args);
};
/* harmony default export */ const functionDefinition = (functionDefinition_render);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/utils.js
function agency_lang_dist_utils_escape(str) {
    return str
        .replace(/\\/g, "\\\\")
        .replace(/"/g, '\\"')
        .replace(/`/g, "\\`")
        .replace(/\$/g, "\\$");
}
function deepCopy(obj) {
    return JSON.parse(JSON.stringify(obj));
}
function zip(arr1, arr2) {
    const length = Math.min(arr1.length, arr2.length);
    const result = [];
    for (let i = 0; i < length; i++) {
        result.push([arr1[i], arr2[i]]);
    }
    return result;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/templates/backends/typescriptGenerator/builtinFunctions/input.js
// THIS FILE WAS AUTO-GENERATED
// Source: lib/templates/backends/typescriptGenerator/builtinFunctions/input.mustache
// Any manual changes will be lost.

const input_template = `function _builtinInput(prompt: string): Promise<string> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  return new Promise((resolve) => {
    rl.question(prompt, (answer: string) => {
      rl.close();
      resolve(answer);
    });
  });
}`;
const input_render = (args) => {
    return apply(input_template, args);
};
/* harmony default export */ const input = (input_render);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/templates/backends/typescriptGenerator/builtinFunctions/read.js
// THIS FILE WAS AUTO-GENERATED
// Source: lib/templates/backends/typescriptGenerator/builtinFunctions/read.mustache
// Any manual changes will be lost.

const read_template = `function _builtinRead(filename: string): string {
  const data = fs.readFileSync(filename);
  const contents = data.toString('utf8');
  return contents;
}`;
const read_render = (args) => {
    return apply(read_template, args);
};
/* harmony default export */ const read = (read_render);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/templates/backends/typescriptGenerator/builtinFunctions/fetchJSON.js
// THIS FILE WAS AUTO-GENERATED
// Source: lib/templates/backends/typescriptGenerator/builtinFunctions/fetchJSON.mustache
// Any manual changes will be lost.

const fetchJSON_template = `async function _builtinFetchJSON(url: string, args: any): any {
  const result = await fetch(url, args);
  try {
    const json = await result.json();
    return json;
  } catch (e) {
    throw new Error(\`Failed to parse JSON from $\{url\}: $\{e\}\`);
  }
}`;
const fetchJSON_render = (args) => {
    return apply(fetchJSON_template, args);
};
/* harmony default export */ const fetchJSON = (fetchJSON_render);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/templates/backends/typescriptGenerator/builtinFunctions/fetch.js
// THIS FILE WAS AUTO-GENERATED
// Source: lib/templates/backends/typescriptGenerator/builtinFunctions/fetch.mustache
// Any manual changes will be lost.

const fetch_template = `async function _builtinFetch(url: string, args: any): any {
  const result = await fetch(url, args);
  try {
    const text = await result.text();
    return text;
  } catch (e) {
    throw new Error(\`Failed to get text from $\{url\}: $\{e\}\`);
  }
}`;
const fetch_render = (args) => {
    return apply(fetch_template, args);
};
/* harmony default export */ const fetch = (fetch_render);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/backends/typescriptGenerator/builtins.js




/**
 * Maps Agency built-in function names to TypeScript equivalents
 */
const BUILTIN_FUNCTIONS = {
    print: "console.log",
    input: "_builtinInput",
    read: "_builtinRead",
    write: "fs.writeFileSync",
    fetch: "_builtinFetch",
    fetchJSON: "_builtinFetchJSON",
    fetchJson: "_builtinFetchJSON",
};
/**
 * Maps an Agency function name to its TypeScript equivalent
 * Returns the original name if not a built-in
 */
function mapFunctionName(functionName) {
    return BUILTIN_FUNCTIONS[functionName] || functionName;
}
/**
 * Generates helper functions for built-in Agency functions
 */
function generateBuiltinHelpers(functionsUsed) {
    const inputFunc = input({});
    const readFunc = read({});
    const fetchJSONFunc = fetchJSON({});
    const helpers = [];
    if (functionsUsed.has("input")) {
        helpers.push(inputFunc);
    }
    if (functionsUsed.has("read")) {
        helpers.push(readFunc);
    }
    if (functionsUsed.has("fetchJSON") || functionsUsed.has("fetchJson")) {
        helpers.push(fetchJSONFunc);
    }
    if (functionsUsed.has("fetch")) {
        const fetchFunc = fetch({});
        helpers.push(fetchFunc);
    }
    return helpers.join("\n\n");
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/backends/typescriptGenerator/typeToString.js
/**
 * Converts a VariableType to a string representation for naming/logging
 */
function variableTypeToString(variableType, typeAliases) {
    if (variableType.type === "primitiveType") {
        return variableType.value;
    }
    else if (variableType.type === "arrayType") {
        // Recursively build array type string
        return `${variableTypeToString(variableType.elementType, typeAliases)}[]`;
    }
    else if (variableType.type === "stringLiteralType") {
        return `"${variableType.value}"`;
    }
    else if (variableType.type === "numberLiteralType") {
        return `${variableType.value}`;
    }
    else if (variableType.type === "booleanLiteralType") {
        return `${variableType.value}`;
    }
    else if (variableType.type === "unionType") {
        return variableType.types
            .map((t) => variableTypeToString(t, typeAliases))
            .join(" | ");
    }
    else if (variableType.type === "objectType") {
        const props = variableType.properties
            .map((prop) => `${prop.key}: ${variableTypeToString(prop.value, typeAliases)}`)
            .join("; ");
        return `{ ${props} }`;
    }
    else if (variableType.type === "typeAliasVariable") {
        return variableType.aliasName;
    }
    return "unknown";
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/backends/typescriptGenerator/typeToZodSchema.js

/**
 * Maps Agency types to Zod schema strings
 */
function mapTypeToZodSchema(variableType, typeAliases) {
    if (variableType.type === "primitiveType") {
        switch (variableType.value.toLowerCase()) {
            case "number":
                return "z.number()";
            case "string":
                return "z.string()";
            case "boolean":
                return "z.boolean()";
            default:
                // Default to string for unknown types
                return "z.string()";
        }
    }
    else if (variableType.type === "arrayType") {
        // Recursively handle array element type
        const elementSchema = mapTypeToZodSchema(variableType.elementType, typeAliases);
        return `z.array(${elementSchema})`;
    }
    else if (variableType.type === "stringLiteralType") {
        return `z.literal("${variableType.value}")`;
    }
    else if (variableType.type === "numberLiteralType") {
        return `z.literal(${variableType.value})`;
    }
    else if (variableType.type === "booleanLiteralType") {
        return `z.literal(${variableType.value})`;
    }
    else if (variableType.type === "unionType") {
        const unionSchemas = variableType.types.map((t) => mapTypeToZodSchema(t, typeAliases));
        return `z.union([${unionSchemas.join(", ")}])`;
    }
    else if (variableType.type === "objectType") {
        const props = variableType.properties
            .map((prop) => {
            let str = `"${prop.key}": ${mapTypeToZodSchema(prop.value, typeAliases)}`;
            if (prop.description) {
                str += `.describe("${agency_lang_dist_utils_escape(prop.description)}")`;
            }
            return str;
        })
            .join(", ");
        return `z.object({ ${props} })`;
    }
    else if (variableType.type === "typeAliasVariable") {
        return mapTypeToZodSchema(typeAliases[variableType.aliasName], typeAliases);
    }
    // Fallback (should never reach here)
    return "z.string()";
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/templates/backends/typescriptGenerator/builtinTools.js
// THIS FILE WAS AUTO-GENERATED
// Source: lib/templates/backends/typescriptGenerator/builtinTools.mustache
// Any manual changes will be lost.

const builtinTools_template = `function add({a, b}: {a:number, b:number}):number {
  return a + b;
}

// Define the function tool for OpenAI
const addTool = {
    type: "function" as const,
    function: {
      name: "add",
      description:
        "Adds two numbers together and returns the result.",
      parameters: {
        type: "object",
        properties: {
          a: {
            type: "number",
            description: "The first number to add",
          },
          b: {
            type: "number",
            description: "The second number to add",
          },
        },
        required: ["a", "b"],
        additionalProperties: false,
      },
    },
  };`;
const builtinTools_render = (args) => {
    return apply(builtinTools_template, args);
};
/* harmony default export */ const builtinTools = (builtinTools_render);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/backends/typescriptGenerator.js











class TypeScriptGenerator extends BaseGenerator {
    constructor() {
        super();
    }
    generateBuiltins() {
        return generateBuiltinHelpers(this.functionsUsed);
    }
    processTypeAlias(node) {
        this.typeAliases[node.aliasName] = node.aliasedType;
        const typeAliasStr = this.typeAliasToString(node);
        this.generatedTypeAliases.push(typeAliasStr);
        return "";
    }
    typeAliasToString(node) {
        const aliasedTypeStr = variableTypeToString(node.aliasedType, this.typeAliases);
        return `type ${node.aliasName} = ${aliasedTypeStr};`;
    }
    processTypeHint(node) {
        if (node.variableType.type === "typeAliasVariable") {
            if (!(node.variableType.aliasName in this.typeAliases)) {
                throw new Error(`Type alias '${node.variableType.aliasName}' not defined for variable '${node.variableName}'.`);
            }
        }
        this.typeHints[node.variableName] = node.variableType;
        return "";
    }
    processAgencyObject(node) {
        const kvCodes = node.entries.map((entry) => {
            const keyCode = entry.key;
            const valueCode = this.processNode(entry.value).trim();
            return `"${keyCode}": ${valueCode}`;
        });
        return `{${kvCodes.join(", ")}}`;
    }
    processAgencyArray(node) {
        const itemCodes = node.items.map((item) => {
            return this.processNode(item).trim();
        });
        return `[${itemCodes.join(", ")}]`;
    }
    processComment(node) {
        return `// ${node.content}\n`;
    }
    processReturnStatement(node) {
        const returnCode = this.processNode(node.value);
        return `return ${returnCode}\n`;
    }
    processAccessExpression(node) {
        switch (node.expression.type) {
            case "dotProperty":
                return this.processDotProperty(node.expression);
            case "indexAccess":
                return this.processIndexAccess(node.expression);
            case "dotFunctionCall":
                return this.processDotFunctionCall(node.expression);
        }
    }
    processMatchBlock(node) {
        let lines = [`switch (${this.generateLiteral(node.expression)}) {`];
        for (const caseItem of node.cases) {
            if (caseItem.type === "comment") {
                lines.push(`  // ${caseItem.content}`);
                continue;
            }
            else if (caseItem.caseValue === "_") {
                lines.push(`  default:`);
            }
            else {
                const caseValueCode = this.processNode(caseItem.caseValue);
                lines.push(`  case ${caseValueCode.trim()}:`);
            }
            const caseBodyCode = this.processNode(caseItem.body);
            lines.push(caseBodyCode);
            lines.push("    break;");
        }
        lines.push("}");
        return lines.join("\n");
    }
    processDotProperty(node) {
        const objectCode = this.processNode(node.object);
        const propertyAccess = `${objectCode}.${node.propertyName}`;
        return propertyAccess;
    }
    processDotFunctionCall(node) {
        const objectCode = this.processNode(node.object);
        const functionCallCode = this.generateFunctionCallExpression(node.functionCall);
        const fullCall = `${objectCode}.${functionCallCode}`;
        return fullCall;
    }
    processIndexAccess(node) {
        const arrayCode = this.processNode(node.array);
        const indexCode = this.processNode(node.index);
        const accessCode = `${arrayCode}[${indexCode}]`;
        return accessCode;
    }
    processAssignment(node) {
        const { variableName, value } = node;
        // Track this variable as in scope
        this.functionScopedVariables.push(variableName);
        if (value.type === "prompt") {
            return this.processPromptLiteral(variableName, value);
        }
        else if (value.type === "functionCall") {
            // Direct assignment for other literal types
            const code = this.processNode(value);
            return `const ${variableName} = await ${code.trim()};` + "\n";
        }
        else {
            // Direct assignment for other literal types
            const code = this.processNode(value);
            return `const ${variableName} = ${code.trim()};` + "\n";
        }
    }
    /*
    protected processAgencyArray(node: AgencyArray): string {
      const itemCodes = node.items.map((item) => {
        if (item.type === "functionCall") { */
    processPromptLiteral(variableName, node) {
        // Validate all interpolated variables are in scope
        const interpolatedVars = node.segments
            .filter((s) => s.type === "interpolation")
            .map((s) => s.variableName);
        for (const varName of interpolatedVars) {
            if (!this.functionScopedVariables.includes(varName)) {
                throw new Error(`Variable '${varName}' used in prompt interpolation but not defined. ` +
                    `Referenced in assignment to '${variableName}'.`);
            }
        }
        const functionCode = this.generatePromptFunction({
            variableName,
            functionArgs: interpolatedVars,
            prompt: node,
        });
        this.generatedStatements.push(functionCode);
        const argsStr = interpolatedVars.join(", ");
        // Generate the function call
        return `const ${variableName} = await _${variableName}(${argsStr});` + "\n";
    }
    processTool(node) {
        const { functionName, body, parameters } = node;
        if (this.graphNodes.includes(functionName)) {
            throw new Error(`There is already a node named '${functionName}'. Functions can't have the same name as an existing node.`);
        }
        const properties = {};
        parameters.forEach((param) => {
            const typeHint = this.typeHints[param] || {
                type: "primitiveType",
                value: "string",
            };
            const tsType = variableTypeToString(typeHint, this.typeAliases);
            properties[param] = { type: tsType, description: "" };
        });
        return tool({
            name: functionName,
            description: node.docString?.value || "No description provided.",
            properties: Object.keys(properties).length > 0 ? JSON.stringify(properties) : "",
            requiredParameters: parameters.map((p) => `"${p}"`).join(","),
        });
    }
    processUsesTool(node) {
        this.toolsUsed.push(node.toolName);
        return "";
    }
    /**
     * Process a function definition node
     */
    processFunctionDefinition(node) {
        const { functionName, body, parameters } = node;
        this.functionScopedVariables = [...parameters];
        const bodyCode = [];
        for (const stmt of body) {
            bodyCode.push(this.processNode(stmt));
        }
        this.functionScopedVariables = [];
        const args = parameters.join(", ") || "";
        return functionDefinition({
            functionName,
            args: "{" + args + "}",
            functionBody: bodyCode.join("\n"),
        });
    }
    /**
     * Process a function call node
     */
    processFunctionCall(node) {
        /*     if (this.functionSignatures[node.functionName] === undefined) {
          throw new Error(
            `Function '${node.functionName}' is not defined or imported.`
          );
        }
     */ this.functionsUsed.add(node.functionName);
        const functionCallCode = this.generateFunctionCallExpression(node);
        return functionCallCode;
    }
    /**
     * Generates TypeScript expression for a function call (without semicolon)
     */
    generateFunctionCallExpression(node) {
        const functionName = mapFunctionName(node.functionName);
        const args = node.arguments;
        const parts = args.map((arg) => {
            if (arg.type === "functionCall") {
                this.functionsUsed.add(arg.functionName);
                return this.generateFunctionCallExpression(arg);
            }
            else if (arg.type === "accessExpression") {
                return this.processAccessExpression(arg);
            }
            else {
                return this.generateLiteral(arg);
            }
        });
        let argsString = "";
        const paramNames = this.functionSignatures[node.functionName];
        if (paramNames) {
            const partsWithNames = zip(paramNames, parts).map(([paramName, part]) => {
                return `${paramName}: ${part}`;
            });
            argsString = partsWithNames.join(", ");
            return `${functionName}({${argsString}})`;
        }
        else {
            // must be a builtin function or imported function,
            // as we don't have the signature info
            // in that case don't do named parameters
            argsString = parts.join(", ");
            return `${functionName}(${argsString})`;
        }
    }
    generateLiteral(literal) {
        switch (literal.type) {
            case "number":
                return literal.value;
            case "string":
                return `"${agency_lang_dist_utils_escape(literal.value)}"`;
            case "variableName":
                return literal.value;
            case "prompt":
                //return this.processPromptLiteral("asd", literal).trim();
                // Reconstruct text for comment from segments
                const text = literal.segments
                    .map((s) => (s.type === "text" ? s.value : `#{${s.variableName}}`))
                    .join("");
                return `/* prompt for: ${text} */`;
        }
    }
    generateImports() {
        let arr = [imports({})];
        arr.push(builtinTools({}));
        return arr.join("\n");
    }
    buildPromptString(segments, typeHints) {
        const promptParts = [];
        for (const segment of segments) {
            if (segment.type === "text") {
                const escaped = agency_lang_dist_utils_escape(segment.value);
                promptParts.push(escaped);
            }
            else {
                // Interpolation segment
                const varName = segment.variableName;
                const varType = typeHints[varName];
                // Serialize complex types to JSON
                if (varType && varType.type === "arrayType") {
                    promptParts.push(`\${JSON.stringify(${varName})}`);
                }
                else {
                    promptParts.push(`\${${varName}}`);
                }
            }
        }
        return "`" + promptParts.join("") + "`";
    }
    /**
     * Generates an async for prompt-based assignments
     */
    generatePromptFunction({ variableName, functionArgs = [], prompt, }) {
        // Generate async function for prompt-based assignment
        const variableType = this.typeHints[variableName] || {
            type: "primitiveType",
            value: "string",
        };
        const zodSchema = mapTypeToZodSchema(variableType, this.typeAliases);
        //console.log("Generated Zod schema for variable", variableName, "Variable type:", variableType, ":", zodSchema, "aliases:", this.typeAliases, "hints:", this.typeHints);
        const typeString = variableTypeToString(variableType, this.typeAliases);
        // Build prompt construction code
        const promptCode = this.buildPromptString(prompt.segments, this.typeHints);
        const argsStr = functionArgs
            .map((arg) => `${arg}: ${variableTypeToString(this.typeHints[arg] || { type: "primitiveType", value: "string" }, this.typeAliases)}`)
            .join(", ");
        const _tools = this.toolsUsed
            .map((toolName) => `${toolName}Tool`)
            .join(", ");
        const tools = _tools.length > 0 ? `[${_tools}]` : "undefined";
        const functionCalls = this.toolsUsed
            .map((toolName) => {
            return toolCall({
                name: toolName,
            });
        })
            .join("\n");
        this.toolsUsed = []; // reset after use
        return promptFunction({
            variableName,
            argsStr,
            typeString,
            promptCode,
            zodSchema,
            tools,
            functionCalls,
        });
    }
    processImportStatement(node) {
        return `import ${node.importedNames} from ${node.modulePath};`;
    }
    processWhileLoop(node) {
        const conditionCode = this.processNode(node.condition);
        const bodyCodes = [];
        for (const stmt of node.body) {
            bodyCodes.push(this.processNode(stmt));
        }
        const bodyCodeStr = bodyCodes.join("\n");
        return `while (${conditionCode}) {\n${bodyCodeStr}\n}\n`;
    }
}
function generateTypeScript(program) {
    const generator = new TypeScriptGenerator();
    return generator.generate(program).output;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/templates/backends/graphGenerator/conditionalEdge.js
// THIS FILE WAS AUTO-GENERATED
// Source: lib/templates/backends/graphGenerator/conditionalEdge.mustache
// Any manual changes will be lost.

const conditionalEdge_template = `graph.conditionalEdge("{{{fromNode}}}", {{{toNodes}}});
`;
const conditionalEdge_render = (args) => {
    return apply(conditionalEdge_template, args);
};
/* harmony default export */ const conditionalEdge = (conditionalEdge_render);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/templates/backends/graphGenerator/imports.js
// THIS FILE WAS AUTO-GENERATED
// Source: lib/templates/backends/graphGenerator/imports.mustache
// Any manual changes will be lost.

const imports_template = `import OpenAI from "openai";
import { zodResponseFormat } from "openai/helpers/zod";
import { z } from "zod";
import * as readline from "readline";
import fs from "fs";
import { Graph, goToNode } from "simplemachine";
import { StatelogClient } from "statelog-client";
import { nanoid } from "nanoid";

const statelogHost = "http://localhost:1065";
const traceId = nanoid();
const statelogClient = new StatelogClient({host: statelogHost, tid: traceId});
const model = "gpt-4.1-nano-2025-04-14";

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

type State = {
  messages: string[];
  data: any;
}

// enable debug logging
const graphConfig = {
  debug: {
    log: true,
    logData: true,
  },
  statelogHost,
  traceId
};

// Define the names of the nodes in the graph
// Useful for type safety
const nodes = {{{nodes:string}}} as const;
type Node = (typeof nodes)[number];

const graph = new Graph<State, Node>(nodes, graphConfig);`;
const graphGenerator_imports_render = (args) => {
    return apply(imports_template, args);
};
/* harmony default export */ const graphGenerator_imports = (graphGenerator_imports_render);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/templates/backends/graphGenerator/startNode.js
// THIS FILE WAS AUTO-GENERATED
// Source: lib/templates/backends/graphGenerator/startNode.mustache
// Any manual changes will be lost.

const startNode_template = `const initialState: State = {messages: [], data: {}};
const finalState = graph.run("{{{startNode}}}", initialState);`;
const startNode_render = (args) => {
    return apply(startNode_template, args);
};
/* harmony default export */ const startNode = (startNode_render);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/templates/backends/graphGenerator/graphNode.js
// THIS FILE WAS AUTO-GENERATED
// Source: lib/templates/backends/graphGenerator/graphNode.mustache
// Any manual changes will be lost.

const graphNode_template = `graph.node("{{{name}}}", async (state) => {
    {{#hasParam}}
    const {{{paramName}}} = state.data;
    {{/hasParam}}
    {{{body}}}
});
`;
const graphNode_render = (args) => {
    return apply(graphNode_template, args);
};
/* harmony default export */ const graphNode = (graphNode_render);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/templates/backends/graphGenerator/builtinTools.js
// THIS FILE WAS AUTO-GENERATED
// Source: lib/templates/backends/graphGenerator/builtinTools.mustache
// Any manual changes will be lost.

const graphGenerator_builtinTools_template = `function add({a, b}: {a:number, b:number}):number {
  return a + b;
}

// Define the function tool for OpenAI
const addTool = {
    type: "function" as const,
    function: {
      name: "add",
      description:
        "Adds two numbers together and returns the result.",
      parameters: {
        type: "object",
        properties: {
          a: {
            type: "number",
            description: "The first number to add",
          },
          b: {
            type: "number",
            description: "The second number to add",
          },
        },
        required: ["a", "b"],
        additionalProperties: false,
      },
    },
  };`;
const graphGenerator_builtinTools_render = (args) => {
    return apply(graphGenerator_builtinTools_template, args);
};
/* harmony default export */ const graphGenerator_builtinTools = (graphGenerator_builtinTools_render);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/templates/backends/graphGenerator/goToNode.js
// THIS FILE WAS AUTO-GENERATED
// Source: lib/templates/backends/graphGenerator/goToNode.mustache
// Any manual changes will be lost.

const goToNode_template = `goToNode("{{{nodeName:string}}}", { messages: state.messages, data: {{{data:string}}} });`;
const goToNode_render = (args) => {
    return apply(goToNode_template, args);
};
/* harmony default export */ const goToNode = (goToNode_render);

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/backends/graphGenerator.js








class GraphGenerator extends TypeScriptGenerator {
    typeHints = {};
    generatedStatements = [];
    generatedTypeAliases = [];
    typeAliases = {};
    functionsUsed = new Set();
    adjacentNodes = {};
    currentAdjacentNodes = [];
    isInsideGraphNode = false;
    constructor() {
        super();
    }
    /*
    protected generateBuiltins(): string {
      return "";
    }
  
    protected processTypeAlias(node: TypeAlias): void {
      // subclasses implement this
    }
  
    protected processTypeHint(node: TypeHint): void {
      // subclasses implement this
    }
  
    protected processNode(node: AgencyNode): string {
      switch (node.type) {
        case "typeHint":
        case "typeAlias":
          return "";
        case "assignment":
          return this.processAssignment(node);
        case "function":
          return this.processFunctionDefinition(node);
        case "functionCall":
          return this.processFunctionCall(node);
        case "accessExpression":
          return this.processAccessExpression(node);
        case "comment":
          return this.processComment(node);
        case "matchBlock":
          return this.processMatchBlock(node);
        case "number":
        case "string":
        case "variableName":
        case "prompt":
          // Standalone literals at top level
          return this.generateLiteral(node);
        case "returnStatement":
          return this.processReturnStatement(node);
        case "agencyArray":
          return this.processAgencyArray(node);
        case "agencyObject":
          return this.processAgencyObject(node);
      }
    }
  
    protected processAgencyObject(node: AgencyObject): string {
      return "<processAgencyObject not implemented>";
    }
  
    protected processAgencyArray(node: AgencyArray): string {
      return "<processAgencyArray not implemented>";
    }
  
    protected processComment(node: AgencyComment): string {
      return "processComment not implemented";
    }
  
    
  
    protected processAccessExpression(node: AccessExpression): string {
      switch (node.expression.type) {
        case "dotProperty":
          return this.processDotProperty(node.expression);
        case "indexAccess":
          return this.processIndexAccess(node.expression);
        case "dotFunctionCall":
          return this.processDotFunctionCall(node.expression);
      }
    }
  
    protected processMatchBlock(node: MatchBlock): string {
      return "processMatchBlock not implemented";
    }
  
    protected processDotProperty(node: DotProperty): string {
      return "processDotProperty not implemented";
    }
  
    protected processDotFunctionCall(node: DotFunctionCall): string {
      return "processDotFunctionCall not implemented";
    }
  
    protected processIndexAccess(node: IndexAccess): string {
      return "processIndexAccess not implemented";
    } */
    /*   protected processAssignment(node: Assignment): string {
      switch (node.value.type) {
        case "prompt":
          return this.processPromptLiteral(node.variableName, node.value);
        default:
          return this.createNode(
            node.variableName,
            this.processNode(wrapInReturn(node.value))
          );
      }
    }
  
    protected createNode(name: string, body: string): string {
      this.graphNodes.push(name);
      return renderNode.default({
        name,
        body,
      });
    }
  
    protected processPromptLiteral(
      variableName: string,
      node: PromptLiteral
    ): string {
      this.graphNodes.push(variableName);
  
      // Validate all interpolated variables are in scope
      const interpolatedVars = node.segments
        .filter((s) => s.type === "interpolation")
        .map((s) => (s as InterpolationSegment).variableName);
  
      for (const varName of interpolatedVars) {
        if (!this.graphNodes.includes(varName)) {
          throw new Error(
            `Variable '${varName}' used in prompt interpolation but not defined. ` +
              `Referenced in assignment to '${variableName}'.`
          );
        }
      }
  
      const promptFunction = this.generatePromptFunction({
        variableName,
        functionArgs: interpolatedVars,
        prompt: node,
      });
      const argsStr = interpolatedVars.join(", ");
  
      return promptNode.default({
        name: variableName,
        promptFunction,
        argsStr,
      });
    }
  
    generatePromptFunction({
      variableName,
      functionArgs = [],
      prompt,
    }: {
      variableName: string;
      functionArgs: string[];
      prompt: PromptLiteral;
    }): string {
      // Generate async function for prompt-based assignment
      const variableType = this.typeHints[variableName] || {
        type: "primitiveType" as const,
        value: "string",
      };
  
      const zodSchema = mapTypeToZodSchema(variableType, this.typeAliases);
      const typeString = variableTypeToString(variableType, this.typeAliases);
  
      // Build prompt construction code
      const promptCode = this.buildPromptString(prompt.segments, this.typeHints);
      const argsStr = functionArgs
        .map(
          (arg) =>
            `${arg}: ${variableTypeToString(
              this.typeHints[arg] || { type: "primitiveType", value: "string" },
              this.typeAliases
            )}`
        )
        .join(", ");
      return promptFunction.default({
        variableName,
        argsStr,
        typeString,
        promptCode,
        zodSchema,
      });
    }
   */
    processReturnStatement(node) {
        if (!this.isInsideGraphNode) {
            return super.processReturnStatement(node);
        }
        else {
            const returnCode = this.processNode(node.value);
            if (node.value.type === "functionCall" &&
                this.graphNodes.includes(node.value.functionName)) {
                // we're going to return a goToNode call, so just return that directly
                return `return ${returnCode}\n`;
            }
            return `return { ...state, data: ${returnCode}}\n`;
        }
    }
    processGraphNodeName(node) {
        this.graphNodes.push(node.nodeName);
    }
    processGraphNode(node) {
        const { nodeName, body, parameters } = node;
        if (parameters.length > 1) {
            throw new Error(`Graph node '${nodeName}' has more than one parameter. Only one parameter is supported for now.`);
        }
        this.adjacentNodes[nodeName] = [];
        this.currentAdjacentNodes = [];
        this.functionScopedVariables = [];
        this.isInsideGraphNode = true;
        if (parameters.length > 0) {
            this.functionScopedVariables.push(parameters[0]);
        }
        const bodyCode = [];
        for (const stmt of body) {
            bodyCode.push(this.processNode(stmt));
        }
        this.functionScopedVariables = [];
        this.adjacentNodes[nodeName] = [...this.currentAdjacentNodes];
        this.isInsideGraphNode = false;
        return graphNode({
            name: nodeName,
            body: bodyCode.join("\n"),
            hasParam: parameters.length > 0,
            paramName: parameters[0] || "input",
        });
    }
    processFunctionCall(node) {
        if (this.graphNodes.includes(node.functionName)) {
            this.currentAdjacentNodes.push(node.functionName);
            this.functionsUsed.add(node.functionName);
            const functionCallCode = this.generateNodeCallExpression(node);
            return functionCallCode;
        }
        else {
            return super.processFunctionCall(node);
        }
    }
    generateNodeCallExpression(node) {
        const functionName = mapFunctionName(node.functionName);
        const args = node.arguments;
        const parts = args.map((arg) => {
            if (arg.type === "functionCall") {
                this.functionsUsed.add(arg.functionName);
                return this.generateFunctionCallExpression(arg);
            }
            else if (arg.type === "accessExpression") {
                return this.processAccessExpression(arg);
            }
            else {
                return this.generateLiteral(arg);
            }
        });
        const argsString = parts.join(", ");
        return goToNode({
            nodeName: functionName,
            data: argsString,
        });
    } /*
  
    protected generateLiteral(literal: Literal): string {
      return "generateLiteral not implemented";
    } */
    generateImports() {
        let arr = [
            graphGenerator_imports({ nodes: JSON.stringify(this.graphNodes) }),
        ];
        arr.push(graphGenerator_builtinTools({}));
        return arr.join("\n");
    }
    postprocess() {
        const lines = [];
        Object.keys(this.adjacentNodes).forEach((node) => {
            const adjacent = this.adjacentNodes[node];
            if (adjacent.length === 0) {
                return;
            }
            lines.push(conditionalEdge({
                fromNode: node,
                toNodes: JSON.stringify(adjacent),
            }));
        });
        if (!this.graphNodes.includes("main")) {
            throw new Error("No entrypoint found for agent: missing 'main' node. Please create a node named 'main'.");
        }
        lines.push(startNode({
            startNode: "main",
        }));
        return lines.join("\n");
    }
}
function generateGraph(program) {
    const generator = new GraphGenerator();
    return generator.generate(program).output;
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/backends/index.js




;// CONCATENATED MODULE: ./node_modules/.pnpm/agency-lang@0.0.2/node_modules/agency-lang/dist/index.js





/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__nccwpck_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__nccwpck_require__.o(definition, key) && !__nccwpck_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__nccwpck_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__nccwpck_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __nccwpck_require__(63);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;